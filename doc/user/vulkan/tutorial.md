# Introduction

## Initialisation

### Initialising Vulkan

The `Vulkan` class is a singleton object that is used to initialise Vulkan:

```java
Vulkan.init();
```

The singleton `Vulkan` object provides access to the following:
* the Vulkan JNA library
* supported extensions and validation layers
* the _reference factory_ (see below)

```java
Vulkan.init();
final Vulkan vulkan = Vulkan.instance();
final VulkanLibrary lib = vulkan.library();
final Supported supported = vulkan.supported();
final ReferenceFactory factory = vulkan.factory();
```

The reference factory is used to request _pass-by-reference_ types that are commonly used throughout the Vulkan API.
This is mainly used to support unit-testing of Vulkan code which is otherwise difficult to achieve.

### Querying required extensions

The GLFW library can be used to determine the required Vulkan extensions in a platform-independent manner:

```java
// Init GLFW service
final DesktopService desktop = new FrameworkDesktopService();

// Check Vulkan is supported
if(!desktop.isVulkanSupported()) ...

// Query platform-dependent required extensions
final String[] required = desktop.extensions();
```

### Creating the Vulkan Instance

A `VulkanInstance` is the 'root' object used to configure the required Vulkan functionality:

```java
final VulkanInstance instance = new VulkanInstance.Builder(vulkan)
	.extensions(required)
	.extension(Extension.DEBUG_UTILS)
	.layer(ValidationLayer.STANDARD_VALIDATION)
	.layer("VK_LAYER_VALVE_steam_overlay", 1)
	.build();
```

In the above example we specify:
* the required extensions determined by GLFW
* the diagnostics extension
* the standard validation layer
* any other extensions or layers that we require

The extensions and layers actually supported by Vulkan can be retrieved using `Vulkan.instance().supported()`.
The application can compare required versus supported functionality prior to building the instance and/or leave the library to perform the checks.
The debug extension and validation layers would generally only be specified for a release build of an application.

### Diagnostics

To enable diagnostics generated by the debugging extension and validation layers we need to attach a message handler to the instance:

```java
instance.handlerFactory().builder()
	.init()
	.build();
```

The `init()` call initialises the message handler to error/warning messages, however the handler can be configured to filter whichever message types and levels in which we are interested.
By default the message handler dumps messages to the console but a custom callback handler can be configured to handle diagnostics. 

## Devices

### Enumerating the Physical Devices

From the instance we can enumerate the available physical devices:

```
final Collection<Pointer> devices = instance.devices();
```

or

```
final List<PhysicalDevice> devices = PhysicalDevice.create(instance);
```

The latter creates _all_ the physical devices.

The physical devices can then be filtered to find the device that we need for our application.
To find a device that supports

TODO

In practice most systems will have a single Vulkan physical device (i.e. a single GPU).

### Creating a Logical Device

Having selected the physical device we can now create a logical device, this is our view of the Vulkan functionality.

 

