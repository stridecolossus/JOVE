# Introduction

TODO

* pipeline
* render loop
* cleanup

# A Sample Vulkan Pipeline

## Initialisation

### Initialising Vulkan

The `Vulkan` class is a singleton object that is used to initialise Vulkan:

```java
Vulkan.init();
```

### Querying required extensions

The GLFW library can be used to determine the required Vulkan extensions in a platform-independent manner:

```java
// Init GLFW service
final DesktopService desktop = new FrameworkDesktopService();

// Check Vulkan is supported
if(!desktop.isVulkanSupported()) ...

// Query platform-dependent required extensions
final String[] requiredExtensions = desktop.extensions();
```

### Creating the Vulkan Instance

A `VulkanInstance` is the 'root' object used to configure the required Vulkan functionality:

```java
final VulkanInstance instance = new VulkanInstance.Builder(vulkan)
	.extensions(requiredExtensions)
	.extension(Extension.DEBUG_UTILS)
	.layer(ValidationLayer.STANDARD_VALIDATION)
	.layer("VK_LAYER_VALVE_steam_overlay", 1)
	.build();
```

In the above example we specify:
* the required extensions determined by GLFW
* the diagnostics extension
* the standard validation layer
* any other extensions or layers that we require

The extensions and layers actually supported by Vulkan can be retrieved using `Vulkan::supported()`.
The application can compare required versus supported functionality prior to building the instance and/or leave the library to perform the checks.
The debug extension and validation layers would generally only be specified for a release build of an application.

### Diagnostics

To enable diagnostics generated by the debugging extension and validation layers we attach a message handler to the instance:

```java
instance.handlerFactory()
	.builder()
	.init()
	.build();
```

The `init()` call initialises the message handler to error/warning messages, however the handler can be configured to specify the message types and levels in which we are interested.
By default the message handler dumps messages to the console but a custom callback handler can be configured to handle diagnostics. 

## Devices

### Enumerating the Physical Devices

From the instance we can enumerate the available physical devices:

```
final Collection<Pointer> devices = instance.devices();
```

or create _all_ the physical devices:

```
final List<PhysicalDevice> devices = PhysicalDevice.create(instance);
```

We can then filter the physical devices to find one that supports the functionality we require:

```java
final VkPhysicalDeviceFeatures requiredFeatures = new VkPhysicalDeviceFeatures();
required.geometryShader = VulkanBoolean.TRUE;
final PhysicalDevice physical = devices.stream().filter(dev -> dev.supports(requiredFeatures).findAny().orElse(...);
```

In practice most systems will have a single Vulkan physical device (i.e. a single GPU).

### Queue Family Discovery

A physical device can be queried for the queue families that it provides and their supported functionality: 

```java
// Find the graphics queue
Predicate<QueueFamily> isGraphics = family -> family.flags().contains(VkQueueFlag.VK_QUEUE_GRAPHICS_BIT);
QueueFamily graphicsFamily = physical.families().stream().filter(isGraphics).orElse(...);

// Find the presentation queue
QueueFamily presentFamily = physical.families().stream().filter(f -> f.isPresentationSupport(surface)).orElse(...);
```

The `surface` used in the predicate for the presentation queue is explained below.

Generally one would query the device features and the available queue families in one step to select the appropriate physical device.

### Creating the Logical Device

Having selected the physical device we can now create a logical device:

```java
final LogicalDevice dev = new LogicalDevice.Builder(physical)
	.queue(graphicsFamily)
	.queue(presentFamily)
	.extension(Extension.SWAP_CHAIN)
	.layer(ValidationLayer.STANDARD_VALIDATION)
	.features(requiredFeatures)
	.build();
```

The `queue()` clause specified that we require a queue of the given family.
There are several overloaded versions of the method that allow us to specify multiple queues, specific priorities, etc.

The logical device is our view of the Vulkan functionality and will be the central collaborator in most of the rest of the code. 

## Vulkan Surface

### Creating a Window

We glossed over the surface used to find the presentation queue earlier, this requires us to:
1. create a GLFW window
2. create a Vulkan surface for the window
3. create a JOVE surface

The GLFW service is used to create a window:

```java
Window.Descriptor descriptor = new Window.Descriptor().Builder()
	.title("title")
	.size(640, 480)
	.property(Window.Descriptor.DISABLE_OPENGL)
	.build();
	
Window window = desktop.window(descriptor);
```

The `Window.Descriptor.DISABLE_OPENGL` prevents GLFW from automatically creating an OpenGL context for the window (which breaks subsequent code).

### Creating the Vulkan Surface

Again we use GLFW to create a Vulkan surface for the window:

```
Surface surface = Surface.create(window.surface(instance), dev); 
```

Note that Vulkan provides functionality to create a platform-specific surface (though not the window) but in general the platform-independent approach is simpler.
However the inter-dependencies between Vulkan and GLFW require some code interleaving which has been omitted for the sake of clarity in this tutorial.

### Creating the Swap-Chain

The swap-chain for a Vulkan surface is created as follows:

```java
SwapChain chain = SwapChain.Builder(dev, surface)
	.count(3)
	.format(VkFormat.VK_FORMAT_B8G8R8A8_UNORM)
	.colourSpace(VkColorSpaceKHR.VK_COLOR_SPACE_SRGB_NONLINEAR_KHR)
	.build();
```

## Render Pass

TODO
shaders
render pass
frame buffers?

## Graphics Pipeline

TODO

## Command Pools and Buffers

### Creating a Command Pool

A command pool and buffers is created from the logical device:

```
// Create a command pool for the rendering work
Command.Pool pool = Command.Pool.create(dev, graphicsFamily);

// Allocate buffers for the number of swap-chain images
List<Command.Buffer> commands = pool.allocate(3, true);
```

### Recording

A command buffer is recording using command objects from the collaborating objects:

```java
command
	.begin(VkCommandBufferUsageFlag.VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT)
	.add(pass.begin(...))
	.add(pipeline.bind())
	.add(draw)
	.add(RenderPass.END_COMMAND)
	.end();
```

The `Command` interface is the base-class for all JOVE command classes.

### Command Buffer Lifecycle

TODO

# The Render Loop

TODO

# Cleanup

TODO
