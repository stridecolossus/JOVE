# Input Events

## Introduction

In this chapter we take a break from Vulkan and build support for input event processing into JOVE, building on the event handling functionality in GLFW.

There are several ways we could have gone about implementing event handling, this is just one of them (and probably not the best).
We discuss the rationale for the design we have chosen and illustrate some of challenges we faced.

## Design

### Background

There are a number of differing types of events provided by GLFW that we will support:

type					| arguments					| device
----					| ---------					| ------
keyboard				| key, press/release		| keyboard
mouse position			| x, y						| mouse
mouse button			| button, press/release		| mouse
mouse wheel				| value						| mouse
window enter/leave		| boolean					| window
window focus			| boolean					| window
controller button		| button, press/release		| controller
controller axis			| axis, value				| controller
controller hat			| hat, press/release		| controller

(There are others but that should be enough for starters!)

A _controller_ is defined here as a joystick, gamepad or console controller.

### Requirements

Whilst we could simply use the GLFW functionality directly in our applications there are compelling reasons to introduce a layer of abstraction:

- The GLFW API requires exposing some underlying details (such as window handle pointers) that we would prefer to protect.

- There is some data we would like to encapsulate such as mapping button modifiers and looking up keyboard key-names.

- Some events are implemented by GLFW as callback handlers e.g. `MousePositionListener` and others as query functions, e.g. `glfwGetJoystickAxes()`.

- Several of the event types map to the same general forms, for example the mouse, controller and hat button events have the same essential structure and data.

- Using GLFW callbacks (for example) mixes application logic and event handling which reduces code re-usability and makes testing more complex.

Therefore we enumerate the requirements for our design:

- Map the various events to a number of generic types.

- Encapsulate the underlying GLFW code that generates input events.

- Implement a _centralised_ mechanism to handle _all_ types of input event.

This is probably best illustrated by some pseudo-code of what we are trying to achieve from the perspective of a developer using the library:

```java
// Define some input events
Button button = new Button("Key_X");		// Keyboard or controller button
Position pos = new Position();				// Mouse position
Axis axis = new Axis(0);						// Mouse wheel axis

// Create a handler 
interface Handler {
    handle(Button.Event);
    handle(Position.Event);
    handle(Axis.Event);
    // etc
}

// Generate some events
handler.handle(button.press());
handler.handle(button.release());
handler.handle(pos.create(1, 2));
handler.handle(axis.create(42));
```

If we can achieve these requirements we can then implement a handler that binds events to _actions_ along these lines:

```java
Bindings bindings = new Bindings();
bindings.bind(new Button("Key_W"), new MoveAction(+1));
bindings.bind(new Button("Key_A"), new StrafeAction(-1));
bindings.bind(new Button("Key_S"), new MoveAction(-1));
bindings.bind(new Button("Key_D"), new StrafeAction(+1));
bindings.bind(Position, camera::orientate);
bindings.bind(axis, new ZoomCameraAction(camera));
```

This separates input event handling from the application logic allowing actions to be more easily re-used across applications and considerably simplifies testing.

## Implementation

### Overview

The various types of event can be generalised to the following:

type 		| arguments 			| examples
---- 		| --------- 			| -------
position	| x, y					| mouse move
button		| id, press/release		| key, mouse button, controller button
axis		| id, value				| joystick, mouse wheel
boolean		| boolean				| window enter/leave



### Input Events

We define an input interface and implementations for the cases we have identified.


### Devices

To encapsulate the GLFW functionality we introduce a _device_ that enumerates the types of event it generates and attaches a general event handler:

```java
interface Device {
	/**
	 * @return Device name
	 */
	String name();

	/**
	 * @return Event types generated by this device
	 */
	Set<Class<? extends Type>> types();

	/**
	 * Enables events of the given type from this device.
	 * @param type			Event type
	 * @param handler		Event handler
	 */
	void enable(Class<? extends Type> type, Handler handler);
}
```

The simplest device manages keyboard events:

```java
```

### Action Bindings




