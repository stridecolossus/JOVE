---
title: Input Handling
---

## Overview

In this chapter we will design a framework for input event handling which will build on to implement an orbital camera controller.

Note there is no new Vulkan functionality introduced in this chapter.

---

## Input Events

### Rationale

Whilst we could simply use the GLFW functionality directly in our application (as we did for the ESCAPE key listener) there are compelling reasons to introduce a layer of abstraction:

* The GLFW API exposes some underlying details (such as window handle pointers) that we would prefer to hide if possible.

* Some events are implemented by GLFW as callback handlers e.g. `MousePositionListener` and others as query functions, e.g. `glfwGetJoystickAxes`.

* Several of the event types map to the same general forms - for example keyboard keys, mouse buttons and controller buttons are essentially equivalent.

* Traditional event callbacks mix application logic and event handling reducing code re-usability and testability.

Based on these observations we enumerate the following requirements for our design:

* Map the various events to a smaller number of general types.

* Encapsulate the underlying GLFW code that generates input events.

* Separate the event handling framework from the application logic.

* Provide a mechanism to map events to application logic that requires minimal configuration (or ideally none).

* Provide functionality to allow an application to query supported events without having to invoke specific API methods.

> Apparently GLFW version 4 will deprecate callbacks in favour of query methods but we will cross that bridge if and when we upgrade the native library.

### Analysis

GLFW supports the following types of events:

type                    | arguments                     | device
----                    | ---------                     | ------
keyboard                | key, action, modifiers        | keyboard
mouse pointer           | x-y                           | mouse
mouse button            | button, action, modifiers     | mouse
mouse wheel             | value                         | mouse
window enter/leave      | boolean                       | window
window focus            | boolean                       | window
controller / joystick   | x-y                           | controller
controller button       | button, press/release         | controller
controller axis         | axis, value                   | controller
controller hat          | hat, press/release            | controller

Notes:

* A _controller_ is defined here as a joystick, gamepad or console controller.

* There are more but the above is enough to be getting on with.

After a bit of analysis we determine that the above can be generalised to the following:

type        | name      | parameterized | arguments     | examples                                          |
----        | ----      | ------------- | ---------     | --------                                          |
position    | no        | no            | x-y           | mouse pointer, controller                         |
button      | yes       | yes           | n/a           | keyboard, mouse buttons, controller buttons       |
axis        | yes       | no            | value         | mouse wheel, controller axis                      |
boolean     | no        | no            | boolean       | window                                            |

Where _name_ specifies whether the event has a name parameter and _parameterized_ indicates an event that has multiple values, e.g. keyboard key names.

### Framework

Based on the above we start with an abstraction for an event:

```java
public interface Event {
    /**
     * @return Type of event
     */
    Type<?> type();
}
```

An _event type_ specifies the static properties of the event:

```java
interface Type<T extends Event> {
    /**
     * @return Event name
     */
    String name();

    /**
     * @return Source of this type of event
     */
    Source source();
}
```

An event _source_ is a binding point for an _action handler_ that consumes events generated by that source:

```java
interface Source {
    /**
     * @return Device
     */
    Device device();

    /**
     * @return Types of events generated by this source
     */
    List<? extends Type<?>> types();

    /**
     * Binds the given handler to this source.
     * @param handler Event handler
     */
    void bind(Consumer<Event> handler);

    /**
     * Disables this source.
     */
    void disable();
}
```

Finally a _device_ is comprised of a number of event sources:

```java
interface Device {
    /**
     * @return Event sources
     */
    Set<Source> sources();

    /**
     * Closes this device.
     */
    void close();
}
```

The purpose of this framework is to:

* Provide a platform-independant mechanism to bind events to a handler (defined as a simple consumer).

* Enumerate the types of event generated by a source.

* Enumerate the event sources for a device.

### Template Implementation

As it turns out the _axis_ event type is probably the simplest case - we will implement an end-to-end solution for the mouse wheel axis.

We start with a template implementation for a GLFW device and event source, which we will then extend to support the mouse wheel.

The `DesktopDevice` encapsulates a reference to the underlying GLFW window:

```java
public abstract class DesktopDevice implements Device {
    private final Window window;

    @Override
    public void close() {
    }
}
```

We next implement a local, template class for a GLFW source belonging to this device:

```java
public abstract class DesktopSource<T> implements Source {
    @Override
    public final Device device() {
        return DesktopDevice.this;
    }

    @Override
    public final void bind(Consumer<Event> handler) {
        ...
    }

    @Override
    public final void disable() {
        ...
    }
}
```

A sub-class of this template is required to implement two methods to support registration of a GLFW listener.  The `listener` method creates a GLFW listener that is responsible for created an event and delegating to a given handler:

```java
/**
 * Creates a listener that generates events and delegates to the given handler.
 * @param handler Event handler
 * @return New GLFW listener
 */
protected abstract T listener(Consumer<Event> handler);
```

The `method` is a provider for the GLFW callback registration method for that listener (similar to how we return a destructor for a Vulkan object):

```java
/**
 * Returns the registration method for the listener.
 * @param lib GLFW library
 * @return Listener registration method
 */
protected abstract BiConsumer<Window, T> method(DesktopLibrary lib);
```

The process of binding a general event handler to a GLFW-specific source is:

1. Create a GLFW listener that delegates to the general event handler via the `listener` method.

2. Retrieve the GLFW callback registration `method` for this listener.

3. Invoke the callback method with the parent window and listener.

This is implemented by the following helper:

```java
private void register(T listener) {
    DesktopLibrary lib = window.desktop().library();
    BiConsumer<Window, T> method = method(lib);
    method.accept(window, listener);
}
```

We can now implement the public methods in terms of this helper:

```java
@Override
public final void bind(Consumer<Event> handler) {
    T listener = listener(handler);
    register(listener);
    window.register(handler, listener);
}

@Override
public final void disable() {
    register(null);
}
```

We add the `register` method to the window class to maintain a reference to a listener:

```java
public class Window {
    private final Map<Object, Object> registry = new WeakHashMap<>();

    protected <T> void register(Consumer<Event> handler, T callback) {
        registry.put(handler, callback);
    }
}
```

This prevents GLFW de-registering a garbage collected listener that is still 'active', i.e. the listener goes out-of-scope at the end of the `bind` method.

Finally we add the mouse device as a lazily instantiated member of the window:

```java
public class Window {
    private final Supplier<MouseDevice> mouse = new LazySupplier<>(() -> new MouseDevice(this));

    public MouseDevice mouse() {
        return mouse.get();
    }
}
```

### Axis

We next define a general class representing an axis and its associated events:

```java
public record Axis(String name, Source source) implements Type<AxisEvent> {
    public class AxisEvent implements Event {
        private final float value;

        public AxisEvent(float value) {
            this.value = value;
        }

        @Override
        public Type<AxisEvent> type() {
            return Axis.this;
        }

        public float value() {
            return value;
        }
    }
}
```

We can now create a GLFW-specific device with an event source for the mouse-wheel:

```java
public class MouseDevice extends DesktopDevice {
    private final MouseWheel wheel = new MouseWheel();

    @Override
    public Set<Source> sources() {
        return Set.of(wheel);
    }

    public Axis wheel() {
        return wheel.axis;
    }
}
```

The `MouseWheel` is a GLFW event source comprising a single axis for the mouse-wheel:

```java
private class MouseWheel extends DesktopSource<MouseScrollListener> {
    private final Axis axis = new Axis("Wheel", this);

    @Override
    public List<Axis> types() {
        return List.of(axis);
    }
}
```

The listener factory creates a GLFW mouse-wheel listener which wraps up the event and delegates it to the handler:

```java
protected MouseScrollListener listener(Consumer<Event> handler) {
    return (ptr, x, y) -> {
        Event e = axis.new AxisEvent((float) y);
        handler.accept(e);
    };
}
```

Finally we specify the callback registration method for the GLFW mouse-wheel:

```java
protected BiConsumer<Window, MouseScrollListener> method(DesktopLibrary lib) {
    return lib::glfwSetScrollCallback;
}
```

Notes:

* The GLFW listener for the mouse-wheel has X and Y arguments but we only need one.

* We also expose the mouse-wheel axis for convenience.

### Position

The next type of event is a _position_ that represents an event source for X-Y location events, we will implement this to support mouse movement events.

The position event type follows the same pattern as the axis:

```java
public record Position(String name, Source source) implements Type<PositionEvent> {
    public class PositionEvent implements Event {
        public final float x, y;

        @Override
        public Type<?> type() {
            return Position.this;
        }
    }
}
```

We use the same framework to implement an event source for the mouse pointer:

```java
private class MousePointer extends DesktopSource<MousePositionListener> {
    private final Position pointer = new Position("Pointer", this);

    @Override
    public List<Position> types() {
        return List.of(pointer);
    }

    @Override
    protected MousePositionListener listener(Consumer<Event> handler) {
        return (ptr, x, y) -> {
            PositionEvent pos = pointer.new PositionEvent((float) x, (float) y);
            handler.accept(pos);
        };
    }

    @Override
    protected BiConsumer<Window, MousePositionListener> method(DesktopLibrary lib) {
        return lib::glfwSetCursorPosCallback;
    }
}
```

Which is added to the mouse device:

```java
public class MouseDevice extends DesktopDevice {
    ...
    private final MousePointer ptr = new MousePointer();

    @Override
    public Set<Source> sources() {
        return Set.of(ptr, wheel);
    }

    public Position pointer() {
        return ptr.pointer;
    }
}
```

### Buttons

The final type of event (for now) is a _button_ that represents keyboard keys, mouse buttons, joystick hats, etc:

```java
public record Button(String id, Source source, Action action, int mods) implements Type<Button>, Event {
    @Override
    public final Type<?> type() {
        return this;
    }
}
```

Notes:

* A button also has an _action_ and a _keyboard modifiers_ mask.

* A button is also its own event type since there are no additional arguments (unlike the axis or position events).

An action is a simple enumeration based on the GLFW action codes:

```java
public enum Action {
    RELEASE,
    PRESS,
    REPEAT
}
```

Similarly for the keyboard modifiers:

```java
public enum Modifier implements IntegerEnumeration {
    SHIFT(0x0001),
    CONTROL(0x0002),
    ALT(0x0004),
    SUPER(0x0008),
    CAPS_LOCK(0x0010),
    NUM_LOCK(0x0020)
}
```

The _name_ of the button is constructed on demand:

```java
public String name() {
    String modifiers = modifiers().stream().map(Enum::name).collect(joining(Event.DELIMITER));
    return Event.name(id, action.name(), modifiers);
}
```

The following helper is added to the event class to build a hyphen-delimited name from a list of tokens:

```java
String DELIMITER = "-";

static String name(String... tokens) {
    return Arrays
        .stream(tokens)
        .filter(Predicate.not(String::isEmpty))
        .collect(joining(DELIMITER));
}
```

Finally we also provide a convenience constructor that generates the _default_ definition of a button:

```java
public Button(String id, Source source) {
    this(id, source, Action.PRESS, 0);
}
```

And the following factory method that derives a button with a specific action and keyboard modifiers from the default button:

```java
public Button resolve(Action action, int mods) {
    return new Button(id, source, action, mods);
}
```

The event source implementation for the GLFW mouse device first generates the list of buttons:

```java
private class MouseButton extends DesktopSource<MouseButtonListener> {
    private final String prefix = Event.name("Mouse", "Button");
    
    private final List<Button> buttons = IntStream
        .rangeClosed(1, MouseInfo.getNumberOfButtons())
        .mapToObj(String::valueOf)
        .map(id -> Event.name(prefix, id))
        .map(name -> new Button(name, this))
        .collect(toList());
    
    @Override
    public List<Button> types() {
        return buttons;
    }
}
```

Surprisingly GLFW does not seem to provide any means of determining the number of mouse buttons supported by the hardware, for the moment we use the AWT `MouseInfo.getNumberOfButtons` method.  However this means that we need to override the default Spring application behaviour which creates a _headless_ application by default (otherwise the AWT method throws an exception):

```java
new SpringApplicationBuilder(ModelDemo.class)
    .headless(false)
    .run(args);
```

The GLFW listener implementation looks up a mouse button by index and uses the `resolve` method to apply the action and keyboard modifiers:

```java
private class MouseButton extends DesktopSource<MouseButtonListener> {
    @Override
    protected MouseButtonListener listener(Consumer<Event> handler) {
        return (ptr, index, action, mods) -> {
            Button button = buttons.get(index);
            Button event = button.resolve(DesktopDevice.map(action), mods);
            handler.accept(event);
        };
    }
    
    @Override
    protected BiConsumer<Window, MouseButtonListener> method(DesktopLibrary lib) {
        return lib::glfwSetMouseButtonCallback;
    }
}
```

In this case since mouse buttons are _parameterized_ we expose the source itself:

```java
public class MouseDevice extends DesktopDevice {
    ...
    private final MouseButton buttons = new MouseButton();

    public DesktopSource<?> buttons() {
        return buttons;
    }
    
    @Override
    public Set<Source> sources() {
        return Set.of(ptr, buttons, wheel);
    }
}
```

We also add a helper to map a GLFW action code to the enumeration:

```java
protected static Action map(int action) {
    return switch(action) {
        case 0 -> Action.RELEASE;
        case 1 -> Action.PRESS;
        case 2 -> Action.REPEAT;
        default -> throw new RuntimeException("Unsupported action code: " + action);
    };
}
```

### Keyboard

The final device we will implement in this chapter is the GLFW keyboard:

```java
public class KeyboardDevice extends DesktopDevice {
    private final KeyboardSource keyboard = new KeyboardSource();

    public DesktopSource<?> source() {
        return keyboard;
    }

    @Override
    public Set<Source> sources() {
        return Set.of(keyboard);
    }
}
```

The keyboard source is implemented as follows:

```java
private class KeyboardSource extends DesktopSource<KeyListener> {
    @Override
    public List<Type<?>> types() {
        return List.of();
    }

    @Override
    protected KeyListener listener(Consumer<Event> handler) {
        ...
    }

    @Override
    protected BiConsumer<Window, KeyListener> method(DesktopLibrary lib) {
        return lib::glfwSetKeyCallback;
    }
}
```

The listener implementation caches the button definition for keyboard keys:

```java
private class KeyboardSource extends DesktopSource<KeyListener> {
    private final Map<Integer, Button> keys = new HashMap<>();

    @Override
    protected KeyListener listener(Consumer<Event> handler) {
        return (ptr, key, scancode, action, mods) -> {
            Button base = keys.computeIfAbsent(key, this::button);
            Button button = base.resolve(DesktopDevice.map(action), mods);
            handler.accept(button);
        };
    }
}
```

A new key definition is created by the following helper:

```java
private Button button(int key) {
    String name = TABLE.get(key);
    if(name == null) throw new RuntimeException("Unknown key code: " + key);
    return new Button(name, KeyboardSource.this);
}
```

Where `TABLE` maps GLFW key codes to key names specified by a local resource (loader not shown).  The key table is a simple text file illustrated in the following fragment:

```
SPACE              32
APOSTROPHE         39
COMMA              44
```

Notes:

* The `types` for the keyboard source is empty since we assume applications will generally refer to keys by name.

* GLFW also provides a _scancode_ argument and the `glfwGetKeyName` API method but this only seems to support a subset of expected keys.

* At the time of writing `TABLE` is hidden as we assume that the GLFW key-codes will not be required outside this framework.

* We add the keyboard device to the GLFW window.

---

## Action Bindings

### Overview

Using this framework we can now bind event sources to handlers, for example:

```java
// Retrieve devices
Mouse mouse = window.mouse();
Keyboard keyboard = window.keyboard();

// Bind stop event
Consumer<Event> kb = e -> {
    ButtonEvent button = (ButtonEvent) e;
    if(button.name().startsWith("ESCAPE")) {
        app.stop();
    }
}
keyboard.bind(kb);

// Bind mouse-wheel handler
Consumer<Event> handler = e -> {
    AxisEvent axis = (AxisEvent) e;
    ...
};
wheel.bind(handler);
```

However there are several problems with this approach:

* We are required to cast the event if we want to use the sub-class properties.

* Ideally we would prefer to bind specific _parameterized_ events (especially for the keyboard, e.g. for the ESCAPE handler) rather than having to implement switching logic.

* Additionally we would also like to be able to bind directly to a method reference with an appropriate signature instead of hand-crafting some sort of adapter.

We could refactor the event class to contain the properties for __all__ cases but this is pretty ugly (even if there are only a handful).  Alternatively we could implement some sort of double-dispatch to transform a base-class event to its sub-type but that feels overkill in this case.

### Bindings

Instead we introduce the _action bindings_ class which is essentially a bi-directional mapping of events to/from handlers:

```java
public class ActionBindings implements Consumer<Event> {
    private final Map<Type<?>, Consumer<Event>> bindings = new HashMap<>();
    private final Map<Object, Set<Type<?>>> map = new HashMap<>();
}
```

The bindings class is itself an event handler:

```java
@Override
public void accept(Event e) {
    Consumer<Event> handler = bindings.get(e.type());
    if(handler != null) {
        handler.accept(e);
    }
}
```

The following generic method binds an arbitrary event type to/from an event handler:

```java
public <T extends Event> void bind(Type<T> type, Consumer<? extends T> handler) {
    // Lookup or create reverse mapping
    var types = map.computeIfAbsent(handler, ignored -> new HashSet<>());

    // Add binding
    bindings.put(type, (Consumer<Event>) consumer);
    types.add(type);
}
```

Note that this method is type-safe at compile-time but down-casts the handler to the base-class event.

We add accessors to retrieve the handler for a given type of event:

```java
public Optional<Consumer<? extends Event>> binding(Type<?> type) {
    return Optional.ofNullable(bindings.get(type));
}
```

And to retrieve the reverse mapping of event types for a given handler:

```java
public Stream<Type<?>> bindings(Consumer<? extends Event> handler) {
    var types = map.get(handler);
    if(types == null) throw new IllegalArgumentException(...);
    return types.stream();
}
```

We also add support (not shown) to remove bindings by handler or event type and to clear all bindings.

### Binding Support

We can now implement convenience methods to bind specific types of event to a method with the appropriate signature.

Generally buttons events will be bound to a `void` method without any parameters (i.e. modelled as a Java `Runnable`) for which we create an event handler adapter:

```java
public Consumer<Button> bind(Type<Button> type, Runnable method) {
    Consumer<Button> handler = ignored -> method.run();
    bind(type, handler);
    return handler;
}
```

Next we add the following interface defining a method that accepts a floating-point X-Y position:

```java
public class Position {
    @FunctionalInterface
    public interface PositionHandler {
        void handle(float x, float y);
    }
}
```

Which is used in a second bind variant for position events:

```java
public Consumer<PositionEvent> bind(Type<PositionEvent> type, PositionHandler adapter) {
    Consumer<PositionEvent> handler = e -> adapter.handle(e.x, e.y);
    bind(type, handler);
    return handler;
}
```

Finally we define a similar bind variant and abstraction for an axis event:

```java
@FunctionalInterface
public interface AxisHandler {
    void handle(float value);
}
```

### Conclusion

A final enhancement is to automatically initialise the sources used in the bindings:

```java
public void init() {
    bindings
        .keySet()
        .stream()
        .map(Type::source)
        .distinct()
        .forEach(src -> src.bind(this));
}
```

The example above can now be refactored using the new class:

```java
// Bind stop event
ActionBindings bindings = new ActionBindings();
Source keyboard = window.keyboard().source();
bindings.bind(new Button("ESCAPE", keyboard), app::stop);

// Bind mouse-wheel handler
AxisHandler handler = e -> ...
bindings.bind(window.mouse().wheel(), handler);

// Init
bindings.init();
```

This framework should deliver the requirements we identified at the start of the chapter:

* The GLFW specifics are now abstracted away (and theoretically could be replaced by an alternative implementation).

* We have successfully separated the event-handling logic from the application code, e.g. for the stop method.

* Binding events to handlers or methods is relatively concise and does not require any casting or switching logic.

So far we have only implemented events that are based on GLFW callbacks, we will address devices that use query methods later (such as a controller or joystick).

---

## Camera Controller

### Overview



### Orbital Controller

### Integration

---












The camera class is a simple model class - to implement richer functionality we introduce a  _camera controller_ that is invoked by action handlers.

An _orbital_ (or arcball) camera controller rotates the view position about a target point-of-interest.

Rather than complicate the existing camera or derive a new sub-class we opt to create a separate _controller_ class:

```java
public class OrbitalCameraController {
    private final Camera cam;
    private Point target = Point.ORIGIN;
    private final Dimensions dim;
}
```

Moving the camera around the _target_ involves the following steps on a positional input event:
1. Map the position to yaw-pitch angles.
2. Calculate the resultant camera position.
3. Point the camera at the target.

This is implemented in the `update` method of the controller:

```java
public void update(float x, float y) {
    final float phi = horizontal.interpolate(x / dim.width());
    final float theta = vertical.interpolate(y / dim.height());
    final Point pos = Sphere.point(phi - MathsUtil.HALF_PI, theta, orbit.radius);
    cam.move(target.add(pos));
    cam.look(target);
}
```

The _phi_ angle is a counter-clockwise rotation about the Y axis (or _yaw_ angle) and _theta_ is the vertical rotation (or _pitch_ angle).  Note that a _phi_ of zero 'points' in the X direction - hence we fiddle the angle by 90 degrees in the `update` method to rotate to the negative Z axis.


Note that the ranges are different for the two rotation axes.

To calculate the camera position we implement a _sphere_ geometry class which calculates a point on the surface of the sphere given a radius and the yaw-pitch angles:

```java
public record Sphere(float radius) {
    ...
    
    public static Point point(float phi, float theta, float radius) {
        final float cos = MathsUtil.cos(theta);
        final float x = radius * cos * MathsUtil.cos(phi);
        final float y = radius * MathsUtil.sin(theta);
        final float z = radius * cos * MathsUtil.sin(phi);
        return new Point(x, y, z);
    }
}
```

The orbital controller also supports a _zoom_ function to move the eye position towards or away from the target:

```java
public void zoom(float inc) {
    final float actual = orbit.zoom(-inc);
    cam.move(actual);
}
```

The _orbit_ properties are factored out to a helper class passed to the controller in its constructor:

```java
public static final class Orbit {
    private final float min;
    private final float max;
    private final float scale;

    private float radius;

    /**
     * Default constructor.
     */
    public Orbit() {
        this(1, Integer.MAX_VALUE, 1);
    }

    /**
     * Constructor.
     * @param min       Minimum radius
     * @param max       Maximum radius
     * @param scale     Zoom scalar
     */
    public Orbit(float min, float max, float scale) {
        if(min >= max) throw new IllegalArgumentException("Invalid zoom range");
        this.min = positive(min);
        this.max = max;
        this.scale = positive(scale);
        this.radius = min;
    }

    /**
     * Increments this radius and clamps to the specified range.
     * @param inc Radius increment
     * @return Actual increment
     */
    private float zoom(float inc) {
        final float prev = radius;
        radius = MathsUtil.clamp(prev + inc * scale, min, max);
        return radius - prev;
    }
}
```

This class clamps the zoom radius to the specified range and prevents the camera being moved onto the target position.

### Integration #3

We can now add an orbital camera controller to the demo and bind it to the mouse pointer and wheel:

```java
// Init camera controller
OrbitalCameraController controller = new OrbitalCameraController(cam, chain.extents(), new Orbit(0.75f, 25, 0.1f));
controller.radius(3);

// Enable mouse
final MouseDevice mouse = window.mouse();
final var pointer = mouse.pointer();
final var wheel = mouse.wheel();
pointer.enable(event -> controller.update(event.x(), event.y()));
wheel.enable(event -> controller.zoom(event.y()));
```

Moving the mouse should rotate the camera about the scene and the mouse-wheel is used to zoom.

Sweet.










### Conclusions

Hopefully the purpose of the event handling framework combined with the bindings class now makes some degree of sense:

- The event handling framework satisfies the requirements of encapsulating the underlying workings of GLFW and reducing the various events to a smaller, more generic subset.

- The bindings class follows the separation of concerns principle by splitting the event handling logic from the application actions (or at least helps).

- This functionality could be used (for example) to implement keyboard/controller bindings in a game without having to craft or refactor event handlers.

- In addition we provide a persistence mechanism to save and load bindings (not shown here).

In the next section we will illustrate how the bindings can be used to control the camera in the model demo.






Up until this point we have just dealt with the fact that the Y direction in Vulkan is **down** (which is inverted compared to OpenGL and just about every other 3D framework).

However we came across a global solution[^invert] that handily flips the Vulkan viewport by specifying a 'negative' viewport rectangle.

We add a _flip_ setting to the `ViewportStageBuilder` which is applied when we populate the viewport descriptor:

```java
private void populate(VkViewport viewport) {
    if(flip) {
        viewport.x = rect.x();
        viewport.y = rect.y() + rect.height();
        viewport.width = rect.width();
        viewport.height = -rect.height();
    }
    else {
        viewport.x = rect.x();
        viewport.y = rect.y();
        viewport.width = rect.width();
        viewport.height = rect.height();
    }
    ...
}
```

Notes:

- This solution is only supported in Vulkan version 1.1.x or above.

- Note that the Y coordinate of the viewport origin is also shifted to the bottom-left of the rectangle.

- To avoid breaking our existing code the _flip_ setting is off by default.



[^invert]: [Flipping the Vulkan viewport](https://www.saschawillems.de/blog/2019/03/29/flipping-the-vulkan-viewport/)

TODO - other refs?


