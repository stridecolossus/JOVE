---
title: Enumerations
---

---

## Contents

- [Background](#background)
- [Solution](#solution)
- [Reverse Mapping](#reverse-mapping)
- [Type Conversion](#type-conversion)
- [Default Values](#default-values)

---

## Background

When first using the code generated enumerations we realised there were a couple of flaws in our thinking:

1. There is also a requirement to map native values to the corresponding enumeration constants, e.g. when retrieving the set of `VkQueueFlag` for a physical device.

2. Additionally many of the enumerations are in fact bit-fields requiring some mechanism to reduce a collection of constants to the native unsigned integer representation (and again to perform the reverse operation).

3. A native enumeration is implemented as an unsigned integer and was being mapped to `int` in the code generated structures and API methods, which is not type-safe and lacks clarity.

For a library with a handful of enumerations these would be minor issues that could be manually implemented, but for the large number of code-generated Vulkan enumerations something more practical is required that works in __all__ cases.

## Solution

What was really needed was some sort of base-class that implemented a common solution, but of course enumerations cannot be sub-classed.  However - although it is not common practice - a Java enumeration _can_ implement an interface (indeed our IDE will not code-complete an interface on an enumeration presumably because it thinks it is not legal Java).

This technique is leveraged to define a common abstraction for the code-generated enumerations to support the above requirements.

The [interface](https://github.com/stridecolossus/JOVE/blob/master/src/main/java/org/sarge/jove/util/IntegerEnumeration.java) itself is trivial:

```java
public interface IntegerEnumeration {
    /**
     * @return Enum literal
     */
    int value();
}
```

The interface is implemented in the template for the code-generated enumerations as illustrated in the following example:

```java
public enum VkImageUsageFlag implements IntegerEnumeration {
    TRANSFER_SRC(1),
    TRANSFER_DST(2),
    ...

    private final int value;
    
    private VkImageUsageFlag(int value) {
        this.value = value;
    }

    @Override
    public int value() {
        return value;
    }
}
```

A static helper can now be implemented to reduce an arbitrary collection of constants to a bit-field:

```java
static <E extends IntegerEnumeration> int reduce(Collection<E> values) {
    return values
        .stream()
        .mapToInt(IntegerEnumeration::value)
        .reduce(0, (a, b) -> a | b);
}
```

## Reverse Mapping

For the other requirements the _reverse mapping_ of the enumeration is generated by the following new supporting class:

```java
final class ReverseMapping<E extends IntegerEnumeration> {
    private final Map<Integer, E> map;

    private ReverseMapping(Class<E> clazz) {
        E[] array = clazz.getEnumConstants();
        this.map = Arrays.stream(array).collect(toMap(IntegerEnumeration::value, Function.identity(), (a, b) -> a));
    }
}
```

Note that some enumerations have constants with duplicate values which are silently ignored when building the reverse mapping.

The enumeration constant for a given native value can now be looked up from the reverse mapping:

```java
public E map(int value) {
    E constant = map.get(value);
    if(constant == null) throw new IllegalArgumentException(...);
    return constant;
}
```

Transforming a bit-field to the corresponding enumeration constants is slightly more involved, the following helper walks the bits of the mask and maps each to the corresponding constant:

```java
public Set<E> enumerate(int bits) {
    int range = Integer.SIZE - Integer.numberOfLeadingZeros(bits);
    return IntStream
        .range(0, range)
        .map(bit -> 1 << bit)
        .filter(value -> (value & bits) == value)
        .mapToObj(this::map)
        .collect(toSet());
}
```

Reverse mappings are generated and cached on demand:

```java
final class ReverseMapping<E extends IntegerEnumeration> {
    private static final Map<Class<?>, ReverseMapping<?>> CACHE = new ConcurrentHashMap<>();

    private static <E extends IntegerEnumeration> ReverseMapping<E> get(Class<?> clazz) {
        return (ReverseMapping<E>) CACHE.computeIfAbsent(clazz, ReverseMapping::new);
    }
}
```

Finally a public factory method is added to lookup a reverse mapping:

```java
static <E extends IntegerEnumeration> ReverseMapping<E> mapping(Class<E> clazz) {
    return ReverseMapping.get(clazz);
}
```

## Type Conversion

JNA uses _type converters_ to marshal Java types to/from their native equivalents and includes built-in converters for standard types (integer, string, pointer, etc).

To use the integer enumerations in a type-safe manner in API methods and structures the following custom converter is implemented:

```java
TypeConverter CONVERTER = new TypeConverter() {
    @Override
    public Class<?> nativeType() {
        return Integer.class;
    }

    @Override
    public Object toNative(Object value, ToNativeContext context) {
        if(value == null) {
            return 0;
        }
        else {
            IntegerEnumeration e = (IntegerEnumeration) value;
            return e.value();
        }
    }

    @Override
    public Object fromNative(Object nativeValue, FromNativeContext context) {
        ReverseMapping<?> mapping = ReverseMapping.get(type);
        return mapping.map(value);
    }
};
```

The converter is registered with a global JNA _type mapper_ in the Vulkan library:

```java
public interface VulkanLibrary ... {
    TypeMapper MAPPER = mapper();

    private static TypeMapper mapper() {
        DefaultTypeMapper mapper = new DefaultTypeMapper();
        mapper.addTypeConverter(IntegerEnumeration.class, IntegerEnumeration.CONVERTER);
        ...
        return mapper;
    }
}
```

The JNA library is configured with this type mapper at instantiation-time:

```java
static VulkanLibrary create() {
    ...
    return Native.load(name, VulkanLibrary.class, Map.of(Library.OPTION_TYPE_MAPPER, MAPPER));
}
```

The only fly in the ointment is that this mapper also needs to be applied to __every__ JNA structure to enable integer enumerations to be used as structure fields, therefore the following intermediate base-class is introduced for all code-generated structures:

```java
public abstract class VulkanStructure extends Structure {
    protected VulkanStructure() {
        super(MAPPER);
    }
}
```

Finally the type mapping logic for structure fields in the code generator is modified to represent constants by the actual enumeration class.  Note that enumerations that are bit-fields remain as integer values (identified by Vulkan enumerations that are suffixed by `Bits`).

## Default Values

The final complication when mapping from a native enumeration value is that a `null` or unspecified value (i.e. zero) may not be a valid enumeration constant.

A default value is introduced to the reverse mapping which is initialised in the constructor:

```java
final class ReverseMapping<E extends IntegerEnumeration> {
    ...
    private final E def;

    private ReverseMapping(Class<E> clazz) {
        this.map = ...
        this.def = map.getOrDefault(0, array[0]);
    }
```

The default value is mapped from the enumeration constant with integer zero if present or is arbitrarily set to the first constant.

In the type converter invalid or unspecified native values can now be safely handled:

```java
public Object fromNative(Object nativeValue, FromNativeContext context) {
    final ReverseMapping<?> mapping = ReverseMapping.get(type);
    final int value = (int) nativeValue;
    if((value == null) || (value == 0)) {
        return mapping.def;
    }
    else {
        return mapping.map(value);
    }
}
```
