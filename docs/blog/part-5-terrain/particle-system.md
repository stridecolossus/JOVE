---
title: Particle System
---

---

## Contents

- [Overview](#overview)
- [Particle System](#particle-system)
- [Intersections](#intersections)
- [Final Touches](#final-touches)

---

## Introduction

### Overview

In this chapter we will implement a _particle system_ that can be configured to support multiple scenarios, such as falling snow, smoke, explosions, etc.
This will build on the point-cloud and geometry shader functionality introduced in the previous chapter.

TODO - software vs hardware

### Requirements

To determine some requirements and constraints for what is considered to be a particle system we sketched a few scenarios and tried to identify some common properties:

scenario    | generation    | emitter   | trajectory    | forces        | bounds        | rendering         |
--------    | ----------    | -------   | ----------    | ----------    | ------        | ---------         |
snow        | constant      | box       | down          | breeze        | ground        | texture           |
fountain    | constant      | point     | ballistic     | gravity       | ground        | blue              |
sparks      | periodic      | point     | ballistic     | gravity       | ground        | colour fade       |
smoke       | constant      | box       | up            | n/a           | time          | colour fade       |
explosion   | once          | sphere    | expanding     | n/a           | time          | colour fade       |
fireworks   | periodic      | point     | ballistic     | gravity       | time          | colour            |

Where:

* A _ballistic_ trajectory is for particles that are 'fired' and implies a gravitational influence.

* The _bounds_ specifies whether particles have a finite lifetime and/or are constrained by some geometric surface.

* A _colour fade_ indicates that the particle colour would fade over time, e.g. smoke particles would perhaps start as grey and fade to black.

From the above the following requirements can be derived:

* Particles are generated according to a configurable policy, either a one-off allocation or replenished per-frame.

* New particles are generated by an emitter.

* Particles follows a trajectory and are subject to influences, e.g. gravity, breeze, etc.

* Particles optionally have a finite lifetime.

* The particle system specifies geometric surfaces (or terrain) where particles are either stopped, destroyed, or reflected (e.g. sparks would bounce a bit).

* Particles have a colour which is either constant or fades over time.

### Design

For the particle system design we considered several alternative approaches (and there are almost certainly others) for how the _trajectory_ of a particle could be specified:

* A particle has a trajectory _function_ that calculates the position of the particle at a given instant (including any influences such as gravity, wind resistance, etc).

* The trajectory is computing in the shader.

* A particle comprises an initial position and movement vector, both of which are mutable.  The movement vector is applied to the particle position on each frame to simulate a trajectory.

There are pros and cons to all of these approaches:

* A trajectory function is appealing in that it encapsulates all the information about how that particle moves over time.  It is therefore simpler to comprehend, reusable, largely immutable, and easier to test in isolation.

* Delegating the trajectory to the shader is logical and almost certainly much more efficient, however this would be very difficult to test or to diagnose.  Additionally GLSL code would have to be cut-and-pasted rather than comprised of coherent, tested components (unless we employed some clever shader generator).

* Mutable particles and movement vectors are probably simpler to implement but slightly more complex to configure.

* A configurable particle system lends itself to being specified later by some configuration file (e.g. an XML document).

After some trials we opted for the simplest approach using mutable particles.  However calculation of the particle colour _is_ deferred to the fragment shader, implying particles additionally have a creation timestamp used to calculate the colour based on age.

We will progressively build up the particle system functionality using the _sparks_ scenario as a test case since this covers the majority of the identified requirements.

---

## Particle System

### Framework

The logical starting point is the definition of a _particle_ which is a mutable type:

```java
public class Particle {
    private final long time;
    private Point pos;
    private Vector dir;
    private Colour col = Colour.WHITE:

    public void move(Vector vec) {
        pos = pos.add(vec);
    }

    public void add(Vector vec) {
        dir = dir.add(vec);
    }
}
```

The _particle system_ is a controller implemented as an animation:

```java
public class ParticleSystem implements Animation {
    private PositionFactory pos = PositionFactory.ORIGIN;
    private VectorFactory vec = VectorFactory.of(Axis.Y);
    private final List<Particle> particles = new ArrayList<>();
    private int max = 1;
}
```

The two configurable factories specify the _emitter_ of the particle system, where the _position factory_ initialises the starting position of new particles:

```java
@FunctionalInterface
public interface PositionFactory {
    /**
     * @return Particle position
     */
    Point position();

    /**
     * Origin factory.
     */
    PositionFactory ORIGIN = of(Point.ORIGIN);

    /**
     * Creates a position factory at the given point.
     * @param pos Position
     * @return Literal position factory
     */
    static PositionFactory of(Point pos) {
        return () -> pos;
    }
}
```

And the _vector factory_ initialises the movement vector:

```java
@FunctionalInterface
public interface VectorFactory {
    /**
     * Generates the initial particle movement vector.
     * @param pos Initial particle position
     * @return Movement vector
     */
    Vector vector(Point pos);

    /**
     * Creates a factory with a fixed initial vector.
     * @param vec Movement vector
     * @return Literal vector factory
     */
    static VectorFactory of(Vector vec) {
        return ignored -> vec;
    }
}
```

These interfaces provide factory methods for literal positions and vectors, more specialised implementations will be added as the demo progresses.

New particles can now be programatically added to the system:

```java
public void add(int num, long time) {
    int actual = Math.min(num, max - size());
    for(int n = 0; n < actual; ++n) {
        Point start = pos.position();
        Vector dir = vec.vector(start);
        Particle p = new Particle(time, start, dir);
        particles.add(p);
    }
}
```

On a frame update the position of each particle is moved by its current direction:

```java
@Override
public boolean update(Animator animator) {
    float elapsed = animator.elapsed() / 1000f; // TODO
    for(Particle p : particles) {
        Vector vec = p.direction().multiply(elapsed);
        p.move(vec);
    }
    return false;
}
```

Note that the _elapsed_ duration is scaled to milliseconds-per-second, i.e. the movement vector is assumed to be expressed as a _velocity_ in seconds.

### Model

To render the particles the following model implementation is essentially an adapter for the particle system:

```java
public class ParticleModel extends AbstractModel {
    private final ParticleSystem sys;

    public ParticleModel(ParticleSystem sys) {
        super(Primitive.POINTS, CompoundLayout.of(Point.LAYOUT));
        this.sys = notNull(sys);
    }

    @Override
    public int count() {
        return sys.size();
    }

    @Override
    public Bufferable vertices() {
        return vertices;
    }
}
```

Where the vertex buffer comprises the particles positions:

```java
private final Bufferable vertices = new Bufferable() {
    @Override
    public int length() {
        return sys.size() * LAYOUT.stride();
    }

    @Override
    public void buffer(ByteBuffer bb) {
        for(Particle p : sys.particles()) {
            p.buffer(bb);
        }
    }
};
```

Where the `buffer` method of the particle outputs the position and colour:

```java
void buffer(ByteBuffer bb) {
    pos.buffer(bb);
    col.buffer(bb);
}
```

### Influences

With a basic framework in place we can now introduce further functionality for the various particle system use-cases outlined above.

An _influence_ modifies some property of the particles on each frame: 

```java
public interface Influence {
    /**
     * Applies this influence to the given particle.
     * @param p             Particle to influence
     * @param elapsed       Elapsed scalar
     */
    void apply(Particle p, float elapsed);
}
```

The simplest implementation simulates an acceleration (e.g. gravity) by modifying the particle movement vector:

```java
static Influence of(Vector vec) {
    return (p, elapsed) -> p.add(vec.multiply(elapsed));
}
```

Influences are applied on each `update` by the following helper:

```java
private void influence(Particle p, float elapsed) {
    for(Influence inf : influences) {
        inf.apply(p, elapsed);
    }
}
```

### Generation

To bound a particle system an optional `lifetime` property is added and expired particles are removed at the start of the `update` method:

```java
if(lifetime < Long.MAX_VALUE) {
    long expired = animator.time() - lifetime;
    particles.removeIf(p -> p.time() < expired);
}
```

In most cases the particle system will be required to generate new particles on each frame, which is configured by the following policy:

```java
public interface GenerationPolicy {
    /**
     * Determines the number of particles to add on each frame.
     * @param current       Current number of particles
     * @param elapsed       Elapsed modifier
     * @return New particles to generate
     */
    int count(int current, float elapsed);

    /**
     * Policy for a particle system that does not generate new particles.
     */
    GenerationPolicy NONE = (current, elapsed) -> 0;
}
```

A basic policy factory is provided for a fixed number of particles:

```java
static GenerationPolicy fixed(int num) {
    return (current, elapsed) -> num - current;
}
```

The following more specialised implementation increments the number of particles:

```java
public class IncrementGenerationPolicy implements GenerationPolicy {
    private final float inc;
    private float pending;
}
```

The `actual` number of particles to generate is integral and `pending` accumulates fractional results between each frame:

```java
public int count(int current, float elapsed) {
    // Accumulate particles to generate
    pending += inc * elapsed;

    // Determine actual number of particles to generate
    int actual = (int) pending;
    pending -= actual;

    return actual;
}
```

A new step is added to the end of the `update` method to generate new particles according to the configured policy:

```java
void generate(float elapsed) {
    int num = policy.count(size(), elapsed);
    if(num > 0) {
        add(num, time);
    }
}
```

### Cone Emitter

Scenarios that involve ballistic trajectories require an emitter that randomises a direction within a cone.

First a new utility class is introduced that wraps a `Random` instance:

```java
public class Randomiser {
    private final Random random;

    public float next() {
        return random.nextFloat();
    }
}
```

This allows code dependant on RNG to be more effectively unit-tested since the `Random` class cannot be easily mocked.

The vector factory to generate a cone is specified as follows:

```java
public class ConeVectorFactory implements VectorFactory {
    private final Vector normal;
    private final Vector x, y;
    private final Interpolator radius;
    private final Randomiser random;
}
```

The `x` and `y` class members define a local coordinate system that is initialised in the constructor:

```java
public ConeVectorFactory(Vector normal, float radius, Randomiser random) {
    this.normal = notNull(normal);
    this.x = normal.cross(Axis.minimal(normal));
    this.y = x.cross(normal);
    this.radius = Interpolator.linear(-radius, +radius);
    this.random = notNull(random);
}
```

Where `minimal` selects an axis corresponding to the _minimum component_ of the normal, which is used to generate a vector orthogonal to the cone:

```java
private static Axis minimal(Vector normal) {
    if(normal.x < normal.y) {
        return normal.x < normal.z ? Axis.X : Axis.Z;
    }
    else {
        return normal.y < normal.z ? Axis.Y : Axis.Z;
    }
}
```

To generate vectors within the cone the normal is randomly rotated about each of the two axes:

```java
protected Vector rotate(Vector axis) {
    float angle = radius.interpolate(random.next());
    var rot = new AxisAngle(axis, angle);
    return rot.rotate(normal);
}
```

And the results are combined:

```java
public Vector vector(Point pos) {
    Vector dx = rotate(x);
    Vector dy = rotate(y);
    return dx.add(dy).normalize();
}
```

The `rotate` method is added to the `Rotation` interface and implemented in the axis-angle class using _Rodrigues' rotation formula_ as follows:

```java
@Override
public Vector rotate(Vector vec) {
    float cos = MathsUtil.cos(angle);
    Vector a = vec.multiply(cos);
    Vector b = axis.cross(vec).multiply(MathsUtil.sin(angle));
    Vector c = axis.multiply((1 - cos) * axis.dot(vec));
    return a.add(b).add(c);
}
```

This algorithm offers an alternative to matrix or quaternion rotations and may be more efficient in certain use-cases.

### Integration

The application for the _sparks_ demo is cloned from the previous project and a new configuration class is added to initialise the particle system:

```java
@Configuration
public class ParticleSystemConfiguration {
    private final ApplicationConfiguration cfg;
    private final ParticleSystem sys;
    private final Model model;
    private final Animator animator;

    @Bean
    public Animator animator() {
        return animator;
    }

    @Bean
    public Model model() {
        return model;
    }
}
```

The particle system, model and animator are instantiated in the constructor:

```java
public ParticleSystemConfiguration() {
    this.sys = system();
    this.animator = new Animator(sys);
    this.model = new ParticleModel(sys);
}
```

The particle system periodically emits a relatively small number of particles per second in a randomised cone:

```java
private static ParticleSystem system() {
    var sys = new ParticleSystem();
    sys.policy(new IncrementGenerationPolicy(10, 100));
    sys.lifetime(5000L);
    sys.vector(new ConeVectorFactory(Axis.Y, 1, new Randomiser()));
    return sys;
}
```

Next the vertex buffer for the particles is created:

```java
@Bean
public VertexBuffer vbo(LogicalDevice dev) {
    var props = new MemoryProperties.Builder<VkBufferUsageFlag>()
        .usage(VkBufferUsageFlag.VERTEX_BUFFER)
        .required(VkMemoryProperty.HOST_VISIBLE)
        .required(VkMemoryProperty.HOST_COHERENT)
        .optimal(VkMemoryProperty.DEVICE_LOCAL)
        .build();

    int len = sys.max() * Point.LAYOUT.length();
    VulkanBuffer buffer = VulkanBuffer.create(dev, len, props);
    return new VertexBuffer(buffer);
}
```

Note that the buffer is sized to the maximum number of particles.

The particle system is written to the VBO on each frame:

```java
@Bean
public Frame.Listener update(VertexBuffer vbo) {
    return () -> {
        Region region = vbo.memory().map();
        ByteBuffer bb = region.buffer();
        model.vertices().buffer(bb);
        region.unmap();
    };
}
```

And finally the animation is started:

```java
@PostConstruct
void start() {
    Player player = new Player();
    player.add(animator);
    player.play();
}
```

The only other modification is in the render configuration where the draw command is created on __each__ frame since the model is now dynamic:

```java
TODO
```

For the moment the fragment shader is a simple pass-through implementation that ignores the generated texture coordinates:

```glsl
#version 450

layout(location=0) in vec2 inCoords;
layout(location=1) in vec4 inColour;

layout(location=0) out vec4 outColour;

void main() {
    outColour = inColour;
}
```

Notes:

* The particle colour is hard-coded to a flat yellow colour.

* The vertex and geometry shaders are unchanged from the previous project.

If all goes well we should see a fountain of yellow quads when running the particle system:

![Basic particle system](particle.quads.png)

---

## Intersections

### Rays

To support particle collisions we introduce _ray intersections_ where a _ray_ is defined as a vector relative to an origin:

```java
public interface Ray {
    /**
     * @return Ray origin
     */
    Point origin();

    /**
     * @return Ray direction
     */
    Vector direction();
}
```

Next a new abstraction defines some arbitrary geometry that can be _intersected_ by a ray:

```java
public interface Intersected {
    /**
     * Determines the intersections of this surface with the given ray.
     * @param ray Ray
     * @return Intersection(s)
     */
    Intersection intersection(Ray ray);
}
```

Where an _intersection_ specifies the distances of each intersection point along the ray and a function to determine the surface normal:

```java
public interface Intersection {
    /**
     * @return Intersection distance(s)
     */
    float[] distances();

    /**
     * @return Whether any intersections are present
     */
    default boolean isEmpty() {
        return false;
    }

    /**
     * Determines the surface normal at the given intersection point on this ray.
     * @param p Intersection point
     * @return Surface normal
     */
    default Vector normal(Point p) {
        throw new UnsupportedOperationException();
    }
}
```

Finally a convenience constant is added for the case of an empty set of results:

```java
Intersection NONE = new Intersection() {
    @Override
    public float[] distances() {
        return new float[0];
    }

    @Override
    public boolean isEmpty() {
        return true;
    }
};
```

The rationale for this rather elaborate API is to allow intersections, and particularly surface normals, to be lazily evaluated since they are not relevant in all use-cases.

For example:

* A collision surface defined to destroy intersected particles only needs to know _whether_ an intersection occurs and not where.

* Surface normals are irrelevant for scene picking.

### Planes

The simplest collision surface implementation is a _plane_ defined by a normal and a distance from the origin:

```java
public record Plane(Vector normal, float distance) implements Intersected {
    public float distance(Point pt) {
        return normal.dot(pt) + distance;
    }
}
```

In addition to the canonical constructor a plane can be specified by the normal and a point on the plane:

```java
public static Plane of(Vector normal, Point pt) {
    return new Plane(normal, -pt.dot(normal));
}
```

Finally a plane can be constructed from a triangle of points lying in the plane:

```java
public static Plane of(Point a, Point b, Point c) {
    Vector u = Axis.between(a, c);
    Vector v = Axis.between(b, c);
    Vector normal = u.cross(v);
    return of(normal, a);
}
```

The standard ray-plane intersection algorithm is implemented as follows:

```java
public Iterator<Intersection> intersections(Ray ray) {
    // Calc denominator
    float denom = normal.dot(ray.direction());

    // Stop if parallel
    if(MathsUtil.isZero(denom)) {
        return NONE;
    }

    // Calc intersection
    float t = -distance(ray.origin()) / denom;
    if(t < 0) {
        return NONE;
    }

    // Build intersection
    return Intersection.of(t, normal);
}
```

Which creates a simple intersection result using a new factory method:

```java
static Intersection of(float d, Vector normal) {
    return new Intersection() {
        @Override
        public float[] distances() {
            return new float[]{d};
        }

        @Override
        public Vector normal(Point p) {
            return normal;
        }
    };
}
```

### Collisions

Particle collisions are configured by an intersecting surface and an associated collision function:

```java
public class ParticleSystem implements Animation {
    private final Map<Intersected, Collision> surfaces = new HashMap<>();
}
```

The particle class is modified to implement the new `Ray` abstraction and can now be tested for collisions:

```java
private void collide(Particle p) {
    for(var entry : surfaces.entrySet()) {
        Intersected surface = entry.getKey();
        Intersection intersection = surface.intersection(p);
        if(!intersections.isEmpty()) {
            Collision collision = entry.getValue();
            collision.collide(p, intersections);
            break;
        }
    }
}
```

A `Collision` defines the operation to be performed on the intersected particle:

```java
public interface Collision {
    /**
     * Applies this collision to the given particle.
     * @param p                 Particle
     * @param intersection      Intersection(s)
     */
    void collide(Particle p, Intersection intersection);
    
    /**
     * Destroys a collided particle.
     */
    Collision DESTROY = (p, __) -> p.destroy();

    /**
     * Stops a collided particle at the given intersection.
     */
    Collision STOP = (p, intersection) -> {
        Point pt = intersection.nearest(p);
        p.stop(pt);
    };
}
```

Where `nearest` selects the _first_ intersection point:

```java
default Point nearest(Ray ray) {
    float[] distances = distances();
    if(distances.length == 0) throw new IllegalStateException();
    return ray.point(distances[0]);
}
```

And `point` calculates a point along the ray, i.e. solves the line equation:

```java
default Point point(float dist) {
    Point origin = this.origin();
    Vector dir = this.direction();
    return origin.add(dir.multiply(dist));
}
```

A destroyed particle is signalled by a `null` position:

```java
public boolean isAlive() {
    return pos != null;
}

void destroy() {
    pos = null;
}
```

And similarly for a particle that has been stopped:

```java
public boolean isIdle() {
    return dir == null;
}

void stop(Point pos) {
    this.pos = notNull(pos);
    this.dir = null;
}
```

Since the `DESTROY` case does not require the actual intersection results the existing ray intersection test is overkill, we only need to know whether the ray is _behind_ the plane.

The _half space_ defines the _sides_ of a plane with respect to the normal, where the `POSITIVE` half-space is in _front_ of the plane:

```java
public enum HalfSpace {
    POSITIVE,
    NEGATIVE,
    INTERSECT
}
```

The half-space for a given distance from the plane is determined by the following helper:

```java
public static HalfSpace of(float d) {
    if(d < 0) {
        return NEGATIVE;
    }
    else
    if(d > 0) {
        return POSITIVE;
    }
    else {
        return INTERSECT;
    }
}
```

Which is also used to determine the half-space for a given point:

```java
public HalfSpace halfspace(Point pt) {
    return HalfSpace.of(distance(pt));
}
```

The following adapter on the plane can now be implemented as an alternative and slightly more efficient intersection test based on the half-space of the ray:

```java
public Intersected negative() {
    return ray -> {
        if(halfspace(ray.origin()) == HalfSpace.POSITIVE) {
            return NONE;
        }
        else {
            return UNDEFINED;
        }
    };
}
```

Where `UNDEFINED` is another constant for an intersection with undefined results:

```java
Intersection UNDEFINED = new Intersection() {
    @Override
    public List<Float> distances() {
        throw new UnsupportedOperationException();
    }
};
```

### Reflection

The slightly more involved reflection case is factored out to a new collision implementation:

```java
public class ReflectionCollision implements Collision {
    private final float absorb;
}
```

Where `absorb` is an optional absorption factor applied on a collision, e.g. to _dampen_ the velocity in the sparks demo.

The particle is reflected about the first intersection point and the absorption factor is applied to the reflected direction:

```java
@Override
public void collide(Particle p, Intersection intersection) {
    Point pt = intersection.nearest(p);
    Vector normal = intersection.normal(pt);
    p.reflect(pt, normal);
    p.velocity(absorb);
}
```

This method delegates to a new particle mutator:

```java
public void reflect(Point pos, Vector normal) {
    this.pos = notNull(pos);
    this.dir = dir.reflect(normal);
}
```

Which in turn delegates to a new method on the vector class to reflect about a given normal:

```java
public Vector reflect(Vector normal) {
    Vector n = normal.normalize();
    float f = -2f * dot(n);
    return n.multiply(f).add(this);
}
```

Note that as things stand this approach simply moves the particle to the intersection point and reflects the movement vector.  This may produce poor results for large elapsed durations since the distance travelled (or remaining) is not taken into account.

There is a further problem when using planes as a reflecting surface, since __all__ rays that cross that plane are considered as intersecting.  In this instance what is really required is an intersection test that only considers rays that have moved behind the plane, and a modification to allow the intersection point to be calculated backwards from the origin.  Therefore the existing code is modified to optionally take this case into account:

```java
private Intersection intersections(Ray ray, boolean pos) {
    ...
    
    // Calc intersection distance
    float d = distance(ray.origin());
    float t = -d / denom;

    // Check for intersection
    if(pos) {
        if(t < 0) {
            return NONE;
        }
    }
    else {
        if(d > 0) {
            return NONE;
        }
    }

    ...
}
```

Where `pos` is a flag indicating whether to include rays in the positive half-space in the intersection test, which is `true` in the general case:

```java
@Override
public Intersection intersection(Ray ray) {
    return intersections(ray, true);
}
```

A further adapter can now be defined that only considers rays in the negative half-space:

```java
public Intersected behind() {
    return ray -> intersections(ray, false);
}
```

The demo is modified by the introduction of an influence to simulate gravity and a collision surface representing the ground:

```java
private static ParticleSystem system(ApplicationConfiguration cfg) {
    ...
    sys.add(Influence.of(Axis.Y.invert()));
    sys.add(new Plane(Axis.Y, 0).behind(), Collision.STOP);
    return sys;
}
```

The particles should now stick to the ground:

![Particle system collisions](particle.ground.png)

Finally the collision surface is modified to reflect particles with a dampening absorption factor on each 'bounce':

```java
sys.add(new Plane(Axis.Y, 0).behind(), new ReflectionCollision(0.3f));
```

---

## Final Touches

### Optimisation

Before progressing any further there are several issues with the existing code:

* Destroyed particles are removed using `removeAll` which is extremely inefficient for this scenario, especially for large numbers of particles.

* The time and elapsed parameters have to be passed around the various methods and lambdas, making the code somewhat messy.

* Ideally the process would employ parallel streams rather than imperative, single-threaded loops.

* Some of the steps are optional, e.g. not all particle systems have a lifetime.

First the `update` method is refactored making the steps and dependencies more explicit:

```java
@Override
public void update(Animator animator) {
    Frame frame = animator.frame();
    long time = frame.time().toEpochMilli();
    float elapsed = frame.elapsed().toMillis() * animator.speed() * SCALE;
    expire(time);
    update(elapsed);
    cull();
    generate(time, elapsed);
}
```

Where `SCALE` modifies the elapsed duration to seconds-per-frame:

```java
private static final float SCALE = 1f / TimeUnit.SECONDS.toMillis(1);
```

Expired particles are _marked_ as destroyed as a parallel stream operation:

```java
private void expire(long time) {
    if(!isLifetimeBound()) {
        return;
    }

    long expired = time - lifetime;

    particles
        .parallelStream()
        .filter(p -> p.time() < expired)
        .forEach(Particle::destroy);
}
```

Where `isLifetimeBound` skips this step if the particle system does not specify a particle lifetime.

The update step is also refactored as a parallel operation:

```java
private void update(float elapsed) {
    Instance instance = new Instance();
    particles
        .parallelStream()
        .filter(Particle::isAlive)
        .filter(Predicate.not(Particle::isIdle))
        .forEach(instance::update);
}                
```

Where `Instance` is a local class comprising the existing update logic that also captures the `elapsed` duration parameter to simplify the code:

```java
class Instance {
    private void update(Particle p) {
        influence(p);
        move(p);
        collide(p);
    }

    ...
}
```

Finally particles that have been destroyed (either by lifetime expiration or a collision) are culled:

```java
private void cull() {
    if(chars.contains(Characteristic.DISABLE_CULLING)) {
        return;
    }

    particles = particles
        .parallelStream()
        .filter(Particle::isAlive)
        .collect(toCollection(ArrayList::new));
}
```

Notes:

* The `Characteristic` enumeration is introduced where `DISABLE_CULLING` is a hint for a particle system that does not expire or destroy particles.

* The reference to the `particles` collection is now mutable and is over-written by the `cull` method.

The code is now much cleaner and employs multiple processor cores.

### Emitters

Several scenarios require an emitter defined as a box (or rectangle) which is implemented by a new type specified by min-max extents:

```java
public record Bounds(Point min, Point max) {
    public Point centre() {
        return min.add(max).multiply(MathsUtil.HALF);
    }
}
```

Particles can now be randomly generated within a given box:

```java
static PositionFactory box(Bounds box, Randomiser randomiser) {
    Point centre = box.centre();
    Vector range = Vector.between(box.min(), box.max()).multiply(MathsUtil.HALF);
    return () -> {
        Vector vec = randomiser.vector().multiply(range);
        return new Point(vec).add(centre);
    };
}
```

Using a new method on the `Randomiser` class:

```java
public class Randomiser {
    ...
    private final float[] array = new float[3];
    private final Interpolator interpolator = Interpolator.linear(-1, +1);

    public Vector vector() {
        for(int n = 0; n < array.length; ++n) {
            array[n] = interpolator.interpolate(next());
        }
        return new Vector(array);
    }
}
```

Where `multiply` is a new method on the the vector class that performs a component-wise multiplication.

The final emitter implementation generates particles on the surface of a sphere:

```java
static PositionFactory sphere(Sphere sphere, Randomiser randomiser) {
    return () -> {
        Vector vec = randomiser.vector().normalize().multiply(sphere.radius());
        return sphere.centre().add(vec);
    };
}
```

Where `Sphere` is a simple tuple for a centre point and a radius.

### Colour Fade

The final outstanding requirements for the sparks demo is animation of the colour and particle textures.

First a further configurable property is added to the particle system to determine the colour of a particle depending on its age:

```java
@FunctionalInterface
public interface ColourFactory {
    /**
     * Determines the colour of a particle.
     * @param t Elapsed scalar
     * @return Particle colour
     */
    Colour colour(float t);

    /**
     * @return Whether the particle colour is modified on each frame
     */
    default boolean isModified() {
        return true;
    }
}
```

A constant colour is specified via a factory method:

```java
static ColourFactory of(Colour col) {
    return new ColourFactory() {
        @Override
        public Colour colour(float __) {
            return col;
        }

        @Override
        public boolean isModified() {
            return false;
        }
    };
}
```

Which is applied once when particles are generated in the `add` method of the particle system:

```java
if(!colour.isModified()) {
    Colour col = colour.colour(0);
    for(Particle p : added) {
        p.colour(col);
    }
}
```

A second implementation interpolates a colour over the lifetime of the particle:

```java
static ColourFactory interpolated(Colour start, Colour end) {
    return t -> start.interpolate(end, t);
}
```

Which delegates to a new interpolator in the colour class:

```java
public Colour interpolate(Colour col, float t) {
    float[] start = this.toArray();
    float[] end = col.toArray();
    for(int n = 0; n < start.length; ++n) {
        start[n] = Interpolator.interpolate(t, start[n], end[n]);
    }
    return of(start);
}
```

The colour factory is configured as follows in the demo:

```java
sys.colour(ColourFactory.interpolated(new Colour(1, 1, 0.5f, 1), new Colour(0.5f, 0, 0, 0)));
```

Particles should now start off bright white-yellow and fade through red to black:

![Particle system colour fade](particle.fade.png)

Note that colour blending is disabled in the pipeline.

### Configuration

Ideally we would like to demonstrate the various particle system scenarios by parameterising the project rather than creating multiple applications, i.e. specify the particle system and shader parameters via configuration files and implement some sort of switch at run-time.

First a new loader is implemented to specify a particle system via a configuration file:

```java
public class ParticleSystemLoader implements ResourceLoader<Element, ParticleSystem> {
    private final ElementLoader loader = new ElementLoader();
    private final Randomiser randomiser;

    @Override
    public Element map(InputStream in) throws IOException {
        return loader.load(new InputStreamReader(in));
    }

    @Override
    public ParticleSystem load(Element root) throws IOException {
        ...
    }
}
```

An `Element` is a custom library type representing a node in a nested configuration file such as an XML, JSON or YAML document.  This class is largely out-of-scope for this blog, but in summary an element is used to:

* Process a document by recursively walking the node tree.

* Extract text and attributes from an element.

* Transform element content to Java primitives.

For example, the generation policy is loaded by the following method:

```java
private GenerationPolicy policy(Element root) {
    return switch(root.name()) {
        case "none" -> GenerationPolicy.NONE;

        case "fixed" -> {
            int num = root.text().toInteger();
            yield GenerationPolicy.fixed(num);
        }

        case "increment" -> {
            int inc = root.text().toInteger();
            yield new IncrementGenerationPolicy(inc);
        }

        default -> throw root.exception(...);
    };
}
```

In this case an XML document seems the most appropriate format to configure the particle system:

```xml
<sparks>
    <max>50</max>
    <policy>
        <increment>10</increment>
    </policy>
    <lifetime>5s</lifetime>
    <position>
        <origin />
    </position>
    <vector>
        <cone>
            <normal>Y</normal>
            <radius>1</radius>
        </cone>
    </vector>
    <colour>
        <interpolated>
            <start>1, 1, 0.5, 1</start>
            <end>0.5, 0, 0, 0</end>
        </interpolated>
    </colour>
    <influences>
        <literal>-Y</literal>
    </influences>
    <surfaces>
        <reflect>
            <behind>
                <normal>Y</normal>
                <distance>0</distance>
            </behind>
            <absorb>0.3</absorb>
        </reflect>
    </surfaces>
</sparks>
```

A Spring _profile_ is used to switch between scenarios configured by a JVM argument:

```java
-Dspring.profiles.active=sparks
```

The profile is injected into the loader to select the scenario-specific configuration file for the particle system:

```java
public ParticleSystemConfiguration(@Value("${spring.profiles.active}") String profile, ...) {
    this.sys = loader.load(profile + ".xml");
    ...
}
```

The `application.properties` is modified to separate the configuration for each scenario as appropriate, as illustrated in the following fragment:

```java
dataDirectory: workspace/Demo/Data
frameCount: 2
features: geometryShader
size: 0.025
shader: particle
texture: particle.png

#---
spring.config.activate.on-profile=sparks
title: Particle System - Sparks
texture: spark.png

#---
spring.config.activate.on-profile=snow
title: Particle System - Snow
size: 0.5
texture: snow.png
```

Notes:

* The first section specifies properties that are common to all profiles.

* The _size_ property is injected into the relevant shaders as a specialisation constant.

A new configuration property is added to specify the fragment shader:

```java
@Bean
Shader fragment(ApplicationConfiguration cfg) {
    return shader(String.format("%s.frag", cfg.getShader()));
}
```

And finally the specified texture is loaded and mixed with the particle colour in the fragment shader:

```glsl
#version 450

layout(binding=1) uniform sampler2D Sampler;

layout(location=0) in vec2 inCoords;
layout(location=1) in vec4 inColour;

layout(location=0) out vec4 outColour;

void main() {
    outColour = inColour * texture(Sampler, inCoords);
}
```

The demo can now be used to run all the scenarios switched by the application argument.  Sweet.

Generally a Spring profile is used to parameterise the configuration of bean components.  The profile could (for example) only load the texture and create a sampler for certain scenarios, but this is not particularly relevant for this demo.

---

## Summary

In this chapter a configurable particle system was implemented with support for planes and ray intersections.
