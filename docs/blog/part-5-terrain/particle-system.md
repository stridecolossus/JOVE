---
title: Particle System
---

---

## Contents

- [Overview](#overview)
- [Particle System](#particle-system)
- [Intersections](#intersections)
- [Final Touches](#final-touches)

---

## Introduction

### Overview

In this chapter we will implement a _particle system_ that can be configured to support multiple scenarios, such as falling snow, smoke, explosions, etc.
This will build on the point-cloud and geometry shader functionality introduced in the previous chapter.

TODO - software vs hardware

### Requirements

To determine some requirements and constraints for what is considered to be a particle system we sketched a few scenarios and tried to identify some common properties:

scenario    | generation    | emitter   | trajectory    | forces        | bounds        | rendering         |
--------    | ----------    | -------   | ----------    | ----------    | ------        | ---------         |
snow        | constant      | box       | down          | breeze        | ground        | texture           |
fountain    | constant      | point     | ballistic     | gravity       | ground        | blue              |
sparks      | periodic      | point     | ballistic     | gravity       | ground        | colour fade       |
smoke       | constant      | box       | up            | n/a           | time          | colour fade       |
explosion   | once          | sphere    | expanding     | n/a           | time          | colour fade       |
fireworks   | periodic      | point     | ballistic     | gravity       | time          | colour            |

Where:

* A _ballistic_ trajectory is for particles that are 'fired' and implies a gravitational influence.

* The _bounds_ specifies whether particles have a finite lifetime or are constrained by some geometric surface.

* A _colour fade_ indicates that the particle colour would fade over time, e.g. smoke particles would perhaps start as grey and fade to black.

From the above the following requirements can be derived:

* Particles are generated according to a configurable policy, either a one-off allocation or replenished per-frame.

* New particles are generated by an emitter.

* Particles follows a trajectory and are subject to influences, e.g. gravity, breeze, etc.

* Particles optionally have a finite lifetime.

* The particle system specifies geometric surfaces (or terrain) where particles are either stopped, destroyed, or reflected (e.g. sparks would bounce a bit).

* Particles have a colour which is either constant or fades over time.

### Design

For the particle system design we considered several alternative approaches (there are almost certainly others) for how the _trajectory_ of a particle could be specified:

* A particle has a trajectory _function_ that calculates the position of the particle at a given instant (including any influences such as gravity, wind resistance, etc).

* The trajectory is computing in the shader.

* A particle comprises an initial position and movement vector, both of which are mutable.  The movement vector is applied to the particle position on each frame to simulate a trajectory.

There are pros and cons to all of these approaches:

* A trajectory function is appealing in that it encapsulates all the information about how that particle moves over time.  It is therefore simpler to comprehend, reusable, largely immutable, and easier to test in isolation.

* Delegating the trajectory to the shader is logical and almost certainly much more efficient, however this would be very difficult to test or to diagnose.  Additionally GLSL code would have to cut-and-pasted rather than comprised of coherent, tested components (unless we employed some clever shader generator).

* Mutable particles and movement vectors is probably simpler to implement but slightly more complex to configure.

* A configurable particle system lends itself to being specified later by some configuration file (e.g. an XML document).

After some trials we opted for the simplest approach using mutable particles.  However calculation of the particle colour _is_ deferred to the fragment shader, implying particles additionally have a creation timestamp used to calculate the colour based on age.

We will progressively build up the particle system functionality using the _sparks_ scenario as a test case since this covers the majority of the identified requirements.

---

## Particle System

### Framework

The logical starting point is the definition of a _particle_ comprising a trajectory and creation timestamp:

```java
public class Particle {
    private final long time;
    private Point pos;
    private Vector dir;

    public void move(Vector vec) {
        pos = pos.add(vec);
    }

    public void add(Vector vec) {
        dir = dir.add(vec);
    }
}
```

The _particle system_ is a controller implemented as an animation:

```java
public class ParticleSystem implements Animation {
    private PositionFactory pos = PositionFactory.ORIGIN;
    private VectorFactory vec = VectorFactory.of(Vector.Y);
    private final List<Particle> particles = new ArrayList<>();
}
```

The two configurable factories specify the _emitter_ of the particle system, where the _position factory_ initialises the starting position of new particles:

```java
@FunctionalInterface
public interface PositionFactory {
    /**
     * @return Particle position
     */
    Point position();

    /**
     * Origin factory.
     */
    PositionFactory ORIGIN = of(Point.ORIGIN);

    /**
     * Creates a position factory at the given point.
     * @param pos Position
     * @return Literal position factory
     */
    static PositionFactory of(Point pos) {
        return () -> pos;
    }
}
```

And the _vector factory_ initialises the movement vector:

```java
@FunctionalInterface
public interface VectorFactory {
    /**
     * Generates the initial particle movement vector.
     * @param pos Initial particle position
     * @return Movement vector
     */
    Vector vector(Point pos);

    /**
     * Creates a factory with a fixed initial vector.
     * @param vec Movement vector
     * @return Literal vector factory
     */
    static VectorFactory of(Vector vec) {
        return ignored -> vec;
    }
}
```

These interfaces provide factory methods for literal positions and vectors, more specialised implementations will be added as the demo progresses.

New particles can now be programatically added to the system:

```java
public void add(int num, long time) {
    for(int n = 0; n < num; ++n) {
        Point start = pos.position();
        Vector dir = vec.vector(start);
        Particle p = new Particle(time, start, dir);
        particles.add(p);
    }
}
```

On a frame update the position of each particle is moved by its current direction:

```java
@Override
public boolean update(Animator animator) {
    float elapsed = animator.elapsed() / 1000f; // TODO
    for(Particle p : particles) {
        Vector vec = p.direction().multiply(elapsed);
        p.move(vec);
    }
    return false;
}
```

Note that the _elapsed_ duration is scaled to milliseconds-per-second, i.e. the movement vector is assumed to be expressed as a _velocity_ in seconds.

### Model

To render the particles the following model implementation is essentially an adapter for the particle system:

```java
public class ParticleModel extends AbstractModel {
    private static final CompoundLayout LAYOUT = CompoundLayout.of(Point.LAYOUT);

    private final ParticleSystem sys;

    public ParticleModel(ParticleSystem sys) {
        super(Primitive.POINTS, LAYOUT);
        this.sys = notNull(sys);
    }

    @Override
    public int count() {
        return sys.size();
    }

    @Override
    public Bufferable vertices() {
        return vertices;
    }
}
```

Where the vertex buffer comprises the particles positions:

```java
private final Bufferable vertices = new Bufferable() {
    @Override
    public int length() {
        return sys.size() * LAYOUT.stride();
    }

    @Override
    public void buffer(ByteBuffer bb) {
        for(Particle p : sys.particles()) {
            p.position().buffer(bb);
        }
    }
};
```

Note that the original model `Header` is now composed into the model class since the draw `count` is no longer a static property (and a separate header record provided little benefit anyway).
A skeleton implementation is also introduced with an empty index buffer.

### Influences

With a basic framework in place we can now introduce further functionality for the various particle system use-cases outlined above.

An _influence_ modifies some property of the particles on each frame: 

```java
public interface Influence {
    /**
     * Applies this influence to the given particle.
     * @param p             Particle to influence
     * @param elapsed       Elapsed scalar
     */
    void apply(Particle p, float elapsed);
}
```

The simplest implementation simulates an acceleration (e.g. gravity) by modifying the particle movement vector:

```java
static Influence of(Vector vec) {
    return (p, elapsed) -> p.add(vec.multiply(elapsed));
}
```

Influences are applied on each `update` by the following helper:

```java
private void influence(Particle p, float elapsed) {
    for(Influence inf : influences) {
        inf.apply(p, elapsed);
    }
}
```

### Generation

To bound a particle system an optional `lifetime` property is added and expired particles are removed at the start of the `update` method:

```java
if(lifetime < Long.MAX_VALUE) {
    long expired = animator.time() - lifetime;
    particles.removeIf(p -> p.time() < expired);
}
```

In most cases the particle system will be required to generate new particles on each frame, which is configured by the following policy:

```java
public interface GenerationPolicy {
    /**
     * Determines the number of particles to add on each frame.
     * @param current       Current number of particles
     * @param elapsed       Elapsed modifier
     * @return New particles to generate
     */
    int count(int current, float elapsed);

    /**
     * Policy for a particle system that does not generate new particles.
     */
    GenerationPolicy NONE = (current, elapsed) -> 0;
}
```

A basic policy factory is provided for a fixed number of particles:

```java
static GenerationPolicy fixed(int num) {
    return (current, elapsed) -> num - current;
}
```

The following more specialised implementation increments the number of particles in the system and applies a maximum cap:

```java
public class IncrementGenerationPolicy implements GenerationPolicy {
    private final float inc;
    private final int max;
    private float pending;
}
```

Where `inc` is the number of particles to generate per-second.

The `actual` number of particles to generate is integral and `pending` accumulates fractional results between each frame:

```java
public int count(int current, float elapsed) {
    // Accumulate particles to generate and clamp
    pending += inc * elapsed;
    pending = Math.min(max - current, pending);

    // Determine actual number of particles to generate
    int actual = (int) pending;
    pending -= actual;

    return actual;
}
```

A new step is added to the end of the `update` method to generate new particles according to the configured policy:

```java
void generate(float elapsed) {
    int num = policy.count(size(), elapsed);
    if(num > 0) {
        add(num, time);
    }
}
```

### Cone Emitter

Scenarios that involve ballistic trajectories require an emitter that randomises a direction within a cone.

First a new utility class is introduced that wraps a `Random` instance:

```java
public class Randomiser {
    private final Random random;

    public float next() {
        return random.nextFloat();
    }
}
```

This allows code dependant on RNG to be more effectively unit-tested since the `Random` class cannot be easily mocked.

The vector factory to generate a cone is specified as follows:

```java
public class ConeVectorFactory implements VectorFactory {
    private final Vector normal;
    private final Vector x, y;
    private final Interpolator radius;
    private final Randomiser random;
}
```

The `x` and `y` class members define a local coordinate system that is initialised in the constructor:

```java
public ConeVectorFactory(Vector normal, float radius, Randomiser random) {
    this.normal = notNull(normal);
    this.x = normal.cross(cardinal(normal));
    this.y = x.cross(normal);
    this.radius = Interpolator.linear(-radius, +radius);
    this.random = notNull(random);
}
```

Where `cardinal` selects an axis corresponding to the _minimum component_ of the normal, which is used to generate a vector orthogonal to the cone:

```java
private static Vector cardinal(Vector normal) {
    if(normal.x < normal.y) {
        return normal.x < normal.z ? Vector.X : Vector.Z;
    }
    else {
        return normal.y < normal.z ? Vector.Y : Vector.Z;
    }
}
```

To generate vectors within the cone the normal is randomly rotated about each of the two axes:

```java
protected Vector rotate(Vector axis) {
    float angle = radius.interpolate(random.next());
    var rot = new AxisAngle(axis, angle);
    return rot.rotate(normal);
}
```

And the results are combined:

```java
public Vector vector(Point pos) {
    Vector dx = rotate(x);
    Vector dy = rotate(y);
    return dx.add(dy).normalize();
}
```

The new `rotate` method on the axis-angle class implements _Rodrigues' rotation formula_ as follows:

```java
public Vector rotate(Vector vec) {
    float cos = MathsUtil.cos(angle);
    Vector a = vec.multiply(cos);
    Vector b = axis.cross(vec).multiply(MathsUtil.sin(angle));
    Vector c = axis.multiply((1 - cos) * axis.dot(vec));
    return a.add(b).add(c);
}
```

This formula offers an alternative to matrix or quaternion rotations and may be more efficient in certain use-cases.
If we ever get round to performance analysis we may decide to replace this code with quaternions later for this scenario.

### Integration

The demo application for the _sparks_ particle system is comprised of the following components:

* A uniform buffer containing _two_ slots for the model-view and projection matrices.

TODO - push constants from previous demo? did that have 3 matrices?

* A fixed camera.

* A pipeline with vertex and fragment shaders (the geometry shader is omitted for the moment).

* And the usual presentation, rendering commands, and frame processor.

A new configuration class is started for the particle system:

```java
@Configuration
public class ParticleSystemConfiguration {
    private final ApplicationConfiguration cfg;
    private final ParticleSystem sys;
    private final Model model;
    private final Animator animator;

    @Bean
    public Animator animator() {
        return animator;
    }

    @Bean
    public Model model() {
        return model;
    }
}
```

The various elements of the particle system are instantiated in the constructor:

```java
public ParticleSystemConfiguration(ApplicationConfiguration cfg) {
    this.cfg = cfg;
    this.sys = system();
    this.animator = new Animator(sys);
    this.model = new ParticleModel(sys);
}
```

The particle system itself is initialised as follows:

```java
private ParticleSystem system() {
    var sys = new ParticleSystem();
    sys.policy(new IncrementGenerationPolicy(10, cfg.getMax()));
    sys.lifetime(5000L);
    sys.vector(new ConeVectorFactory(Vector.Y, 1, new Randomiser()));
    sys.add(Influence.of(Vector.Y.invert()));
    return sys;
}
```

Here the sparks demo is configured by:

* Periodically emitting a relatively small number of particles per second.

* Particles are fired upwards in a randomised cone.

* An influence that pulls particles downwards simulating gravity.

Next the vertex buffer for the particles is created:

```java
@Bean
public VertexBuffer vbo(LogicalDevice dev) {
    var props = new MemoryProperties.Builder<VkBufferUsageFlag>()
        .usage(VkBufferUsageFlag.VERTEX_BUFFER)
        .required(VkMemoryProperty.HOST_VISIBLE)
        .required(VkMemoryProperty.HOST_COHERENT)
        .optimal(VkMemoryProperty.DEVICE_LOCAL)
        .build();

    int len = cfg.getMax() * Point.LAYOUT.length();
    VulkanBuffer buffer = VulkanBuffer.create(dev, len, props);
    return new VertexBuffer(buffer);
}
```

Note that the buffer is sized to the maximum number of particles.

The particle system is written to the VBO on each frame:

```java
@Bean
public Frame.Listener update(VertexBuffer vbo) {
    return () -> {
        Region region = vbo.memory().map();
        ByteBuffer bb = region.buffer();
        model.vertices().buffer(bb);
        region.unmap();
    };
}
```

And finally the animation is started:

```java
@PostConstruct
void start() {
    Player player = new Player();
    player.add(animator);
    player.state(State.PLAY);
}
```

TODO - dynamic draw command

```glsl
#version 450

layout(location=0) in vec3 pos;

layout(binding=0) uniform UniformBuffer {
    mat4 modelview;
    mat4 projection;
};

void main() {
    gl_PointSize = 10;
    gl_Position = projection * modelview * vec4(pos, 1.0);
}
```

The reason for separate matrices in the uniform buffer will become relevant later.

For the moment the fragment shader outputs a flat yellow colour.

TODO - pic

---

## Intersections

### Rays

To support particle collisions we introduce _ray intersections_ where a _ray_ is defined as a vector relative to an origin:

```java
public interface Ray {
    /**
     * @return Ray origin
     */
    Point origin();

    /**
     * @return Ray direction
     */
    Vector direction();
}
```

The following helper is used to determine a point on the ray at a given distance from the origin, i.e. solves the line equation:

```java
default Point point(float dist) {
    Point origin = this.origin();
    Vector dir = this.direction();
    return origin.add(dir.multiply(dist));
}
```

Next a new abstraction defines some arbitrary geometry that can be _intersected_ by a ray:

```java
public interface Intersected {
    /**
     * Determines the intersections of this surface with the given ray.
     * @param ray Ray
     * @return Intersection(s)
     */
    Intersection intersection(Ray ray);
}
```

Where an _intersection_ specifies the distances of each intersection point along the ray and a function to determine the surface normal:

```java
public interface Intersection {
    /**
     * @return Intersection distance(s)
     */
    float[] distances();

    /**
     * @return Whether any intersections are present
     */
    default boolean isEmpty() {
        return false;
    }

    /**
     * Determines the surface normal at the given intersection point on this ray.
     * @param p Intersection point
     * @return Surface normal
     */
    default Vector normal(Point p) {
        throw new UnsupportedOperationException();
    }
}
```

Finally a convenience constant is added for the case of an empty set of results:

```java
Intersection NONE = new Intersection() {
    @Override
    public float[] distances() {
        return new float[0];
    }

    @Override
    public boolean isEmpty() {
        return true;
    }
};
```

The rationale for this rather elaborate API is to allow intersections, and particularly surface normals, to be lazily evaluated since they are not relevant in all use-cases.

For example:

* A collision surface defined to destroy intersected particles only needs to know _whether_ an intersection occurs and not where.

* Surface normals are irrelevant for scene picking.

### Planes

The simplest collision surface implementation is a _plane_ defined by a normal and a distance from the origin:

```java
public record Plane(Vector normal, float distance) implements Intersected {
    public float distance(Point pt) {
        return normal.dot(pt) + distance;
    }
}
```

In addition to the canonical constructor a plane can be specified by the normal and a point on the plane:

```java
public static Plane of(Vector normal, Point pt) {
    return new Plane(normal, -pt.dot(normal));
}
```

Finally a plane can be constructed from a triangle of points lying in the plane:

```java
public static Plane of(Point a, Point b, Point c) {
    Vector u = Vector.between(a, c);
    Vector v = Vector.between(b, c);
    Vector normal = u.cross(v).normalize();
    return of(normal, a);
}
```

The standard ray-plane intersection algorithm is implemented as follows:

```java
public Iterator<Intersection> intersections(Ray ray) {
    // Calc denominator
    float denom = normal.dot(ray.direction());

    // Stop if parallel
    if(MathsUtil.isZero(denom)) {
        return NONE;
    }

    // Calc intersection
    float t = -distance(ray.origin()) / denom;
    if(t < 0) {
        return NONE;
    }

    // Build intersection
    return Intersection.of(t, normal);
}
```

Which creates a simple intersection result using a new factory method:

```java
static Intersection of(float d, Vector normal) {
    return new Intersection() {
        @Override
        public float[] distances() {
            return new float[]{d};
        }

        @Override
        public Vector normal(Point p) {
            return normal;
        }
    };
}
```

### Collisions

Particle collisions are configured by an intersecting surface and an associated collision function:

```java
public class ParticleSystem implements Animation {
    private final Map<Intersected, Collision> surfaces = new HashMap<>();
}
```

The particle class is modified to implement the new `Ray` abstraction and can now be tested for collisions:

```java
private void collide(Particle p) {
    for(var entry : surfaces.entrySet()) {
        Intersected surface = entry.getKey();
        Intersection intersection = surface.intersection(p);
        if(!intersections.isEmpty()) {
            Collision collision = entry.getValue();
            collision.collide(p, intersections);
            break;
        }
    }
}
```

A `Collision` defines the operation to be performed on the intersected particle and provides default implementations:

```java
public interface Collision {
    /**
     * Applies this collision to the given particle.
     * @param p                 Particle
     * @param intersection      Intersection(s)
     */
    void collide(Particle p, Intersection intersection);
    
    /**
     * Destroys a collided particle.
     */
    Collision DESTROY = (p, ignored) -> p.destroy();

    /**
     * Stops a collided particle at the given intersection.
     */
    Collision STOP = (p, intersection) -> {
        Point pt = Intersection.point(p, intersection);
        p.stop(pt);
    };
}
```

Where a destroyed particle is signalled by a `null` position:

```java
public boolean isAlive() {
    return pos != null;
}

void destroy() {
    pos = null;
}
```

And similarly for a particle that has been stopped:

```java
public boolean isIdle() {
    return dir == null;
}

void stop(Point pos) {
    this.pos = notNull(pos);
    this.dir = null;
}
```

The `DESTROY` case does not require the actual intersection results, the ray intersection test is overkill in this case since we only need to know whether the ray is _behind_ the plane.

The _half space_ defines the _sides_ of a plane with respect to the normal, where the `POSITIVE` half-space is in _front_ of the plane:

```java
public enum HalfSpace {
    POSITIVE,
    NEGATIVE,
    INTERSECT
}
```

The half-space for a given distance from the plane is determined by the following helper:

```java
public static HalfSpace of(float d) {
    if(d < 0) {
        return NEGATIVE;
    }
    else
    if(d > 0) {
        return POSITIVE;
    }
    else {
        return INTERSECT;
    }
}
```

Which is also used to determine the half-space for a given point:

```java
public HalfSpace halfspace(Point pt) {
    return HalfSpace.of(distance(pt));
}
```

The following adapter on the plane can now be implemented as an alternative and slightly more efficient intersection test based on the half-space of the ray:

```java
public Intersected negative() {
    return ray -> {
        if(halfspace(ray.origin()) == HalfSpace.POSITIVE) {
            return NONE;
        }
        else {
            return UNDEFINED;
        }
    };
}
```

Where `UNDEFINED` is another constant for an intersection with undefined results:

```java
Intersection UNDEFINED = new Intersection() {
    @Override
    public List<Float> distances() {
        throw new UnsupportedOperationException();
    }
};
```

### Reflection

The reflection case is slightly more involved, the particle is reflected about the first (arbitrarily selected) intersection:

```java
Collision REFLECT = (p, intersection) -> {
    Point pt = Intersection.point(p, intersection);
    Vector normal = intersection.normal(pt);
    p.reflect(pt, normal);
};
```

Which delegates to the following new particle mutator:

```java
public void reflect(Point pos, Vector normal) {
    this.pos = notNull(pos);
    this.dir = dir.reflect(normal);
}
```

Which in turn delegates to a new method on the vector class to reflect about a given normal:

```java
public Vector reflect(Vector normal) {
    float f = -2f * dot(normal);
    return normal.multiply(f).add(this);
}
```

Note that as things stand this approach simply sets the particle at the intersection point and reflects the movement vector.
This may produce poor results for large elapsed durations since the distance travelled (or remaining) is not taken into account.

There is a further complication here: if a reflecting surface is defined in terms of a plane then __all__ rays that cross that plane are considered as intersecting.  What is required is an intersection test that only considers rays in the negative half-space.  The `negative` adapter and the default ray-plane intersection test could be composed together but this means the distance logic is essentially being calculated twice which feels wrong.  Therefore the existing intersection test is modified to optionally take into account the half-space:

```java
private Intersection intersections(Ray ray, boolean pos) {
    ...
    
    // Calc intersection distance
    float d = distance(ray.origin());
    float t = -d / denom;

    // Check for intersection
    if(pos) {
        if(t < 0) {
            return NONE;
        }
    }
    else {
        if(d > 0) {
            return NONE;
        }
    }

    ...
}
```

Where `pos` is a flag indicating whether to include rays in the positive half-space in the intersection test, which is `true` in the general case:

```java
@Override
public Intersection intersection(Ray ray) {
    return intersections(ray, true);
}
```

We can now define a further adapter that only considers rays in the negative half-space:

```java
public Intersected behind() {
    return ray -> intersections(ray, false);
}
```

Which is what will be used in the demo application to reflect particles at the collision surface.

### Integration



* Definition of a collision surface simulating the 'ground' that reflects particles.
colour fade


TODO - multiple scenarios ~ Spring profile

significantly faster, can see multiple cores

---

## Final Touches

### Parallel Refactor

Before progressing any further there are now several issues with the existing code:

* Particles that are destroyed by a collision are removed using `removeAll` which is extremely inefficient for this scenario, especially for large numbers of particles.

* The time and elapsed parameters have to be passed around the various methods and lambdas, making the code somewhat messy.

* Ideally the process would employ parallel streams rather than imperative, single-threaded loops.

Therefore a new local helper class is implemented that encapsulates the update process:

```java
private class Helper {
    private static final float SECONDS = 1f / TimeUnit.SECONDS.toMillis(1);

    private final long time;
    private final float elapsed;

    private Helper(Animator animator) {
        this.time = animator.time();
        this.elapsed = animator.elapsed() * SECONDS;
    }
}
```

An instance is created on each frame and the code is simplified to the main steps:

```java
public boolean update(Animator animator) {
    Helper helper = new Helper(animator);
    helper.expire();
    helper.update();
    helper.cull();
    helper.generate();
    return false;
}
```

Expired particles are now destroyed as a parallel stream operation:

```java
void expire() {
    if(lifetime == Long.MAX_VALUE) {
        return;
    }

    long expiry = time - lifetime;

    particles
        .parallelStream()
        .filter(p -> p.time() < expiry)
        .forEach(Particle::destroy);
}
```

And the update step is refactored similarly to the following cleaner and parallelised code:

```java
void update() {
    particles
        .parallelStream()
        .filter(Particle::isAlive)
        .filter(Predicate.not(Particle::isIdle))
        .forEach(this::update);
}
```

Which invokes the following method comprising the existing code for each particle:

```java
private void update(Particle p) {
    influence(p);
    move(p);
    collide(p);
}
```

Finally particles that have expired or been destroyed by a collision are culled:

```java
void cull() {
    particles = particles
        .parallelStream()
        .filter(Particle::isAlive)
        .collect(toCollection(ArrayList::new));
}
```

Note that the reference to the `particles` collection is now mutable and is over-written in this method.

### Colour Fade

The last requirement is calculation of the particle colour

fragment shader

### Box Emitter

Several scenarios require an emitter defined as a box (or rectangle) which is implemented by a new type specified by min-max extents:

```java
public record Bounds(Point min, Point max) {
    public Point centre() {
        return min.add(max).multiply(MathsUtil.HALF);
    }
}
```

Particles can now be randomly generated within this volume:

```java
static PositionFactory box(Bounds bounds, Randomiser randomiser) {
    Point min = bounds.min();
    Vector range = Vector.between(min, bounds.max());
    return () -> {
        Vector vec = randomiser.vector().multiply(range);
        return new Point(vec).add(min);
    };
}
```

Using using a new method on the `Randomiser` class:

```java
public class Randomiser {
    ...
    private final float[] array = new float[3];
    private final Interpolator interpolator = Interpolator.linear(-1, +1);

    public Vector vector() {
        for(int n = 0; n < array.length; ++n) {
            array[n] = interpolator.interpolate(next());
        }
        return new Vector(array);
    }
}
```

Where `multiply` is a new method on the the vector class that performs a component-wise multiplication operation.

### Integration

geometry shader for billboards
modified vertex shader
load particle sprite?
point size to one?


---

## Colour Blending

TODO - move to galaxy demo chapter

To enable colour blending in the demo a new pipeline stage is introduced:

```java
public class ColourBlendPipelineStageBuilder extends AbstractPipelineStageBuilder<VkPipelineColorBlendStateCreateInfo> {
    private final VkPipelineColorBlendStateCreateInfo info = new VkPipelineColorBlendStateCreateInfo();

    public ColourBlendPipelineStageBuilder() {
        info.logicOpEnable = VulkanBoolean.FALSE;
        info.logicOp = VkLogicOp.COPY;
        Arrays.fill(info.blendConstants, 1);
    }
}
```

The global blending properties are configured as follows:

```java
public ColourBlendPipelineStageBuilder enable(boolean enabled) {
    info.logicOpEnable = VulkanBoolean.of(enabled);
    return this;
}

public ColourBlendPipelineStageBuilder operation(VkLogicOp op) {
    info.logicOp = notNull(op);
    return this;
}

public ColourBlendPipelineStageBuilder constants(float[] constants) {
    System.arraycopy(constants, 0, info.blendConstants, 0, constants.length);
    return this;
}
```

The blending configuration for each colour attachment is implemented as a nested builder:

```java
public AttachmentBuilder attachment() {
    return new AttachmentBuilder();
}
```

Which specifies the logical operation between a fragment and the existing colour in the framebuffer attachment(s).

```java
public class AttachmentBuilder {
    private boolean enabled = true;
    private int mask = IntegerEnumeration.reduce(VkColorComponent.values());
    private final BlendOperationBuilder colour = new BlendOperationBuilder();
    private final BlendOperationBuilder alpha = new BlendOperationBuilder();

    private AttachmentBuilder() {
        colour.source(VkBlendFactor.SRC_ALPHA);
        colour.destination(VkBlendFactor.ONE_MINUS_SRC_ALPHA);
        alpha.source(VkBlendFactor.ONE);
        alpha.destination(VkBlendFactor.ZERO);
        attachments.add(this);
    }
}
```

The colour `mask` is used to specify which channels are subject to the blend operation, expressed as a simple string:

```java
public AttachmentBuilder mask(String mask) {
    this.mask = mask
        .chars()
        .mapToObj(Character::toString)
        .map(VkColorComponent::valueOf)
        .collect(collectingAndThen(toList(), IntegerEnumeration::reduce));

    return this;
}
```

The properties for the colour and alpha components are identical so a further nested builder configures both values:

```java
public class BlendOperationBuilder {
    private VkBlendFactor src;
    private VkBlendFactor dest;
    private VkBlendOp blend = VkBlendOp.ADD;

    private BlendOperationBuilder() {
    }

    public AttachmentBuilder build() {
        return AttachmentBuilder.this;
    }
}
```

The descriptor for the attachment is generated in the nested builder as follows:

```java
private void populate(VkPipelineColorBlendAttachmentState info) {
    // Init descriptor
    info.blendEnable = VulkanBoolean.of(enabled);
    info.colorWriteMask = mask;

    // Init colour blending operation
    info.srcColorBlendFactor = colour.src;
    info.dstColorBlendFactor = colour.dest;
    info.colorBlendOp = colour.blend;

    // Init alpha blending operation
    info.srcAlphaBlendFactor = alpha.src;
    info.dstAlphaBlendFactor = alpha.dest;
    info.alphaBlendOp = alpha.blend;
}
```

And finally the descriptor for the pipeline stage can be constructed:

```java
@Override
VkPipelineColorBlendStateCreateInfo get() {
    // Init default attachment if none specified
    if(attachments.isEmpty()) {
        new AttachmentBuilder().build();
    }

    // Add attachment descriptors
    info.attachmentCount = attachments.size();
    info.pAttachments = StructureHelper.pointer(attachments, VkPipelineColorBlendAttachmentState::new, AttachmentBuilder::populate);

    return info;
}
```

Note that by convenience a single, default attachment is added if none are configured (at least one must be specified).

The pipeline configuration can now be updated to apply an additive blending operation in the demo:

```java
.blend()
    .enable(true)
    .operation(VkLogicOp.COPY)
    .attachment()
        .colour()
            .destination(VkBlendFactor.ONE)
            .build()
        .build()
    .get();
```

---

## Summary

In this chapter a configurable particle system was implemented with support for planes and ray intersections.
