package org.sarge.jove.platform.vulkan.core;

import static java.util.stream.Collectors.joining;
import static org.sarge.jove.platform.vulkan.core.VulkanLibrary.check;
import static org.sarge.lib.util.Check.notNull;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.StringJoiner;
import java.util.function.Consumer;
import java.util.function.Supplier;
import java.util.stream.Stream;

import org.apache.commons.lang3.builder.ToStringBuilder;
import org.sarge.jove.common.AbstractTransientNativeObject;
import org.sarge.jove.platform.vulkan.VkDebugUtilsMessageSeverity;
import org.sarge.jove.platform.vulkan.VkDebugUtilsMessageType;
import org.sarge.jove.platform.vulkan.VkDebugUtilsMessengerCallbackData;
import org.sarge.jove.platform.vulkan.VkDebugUtilsMessengerCreateInfoEXT;
import org.sarge.jove.util.IntegerEnumeration;
import org.sarge.lib.util.Check;
import org.sarge.lib.util.LazySupplier;

import com.sun.jna.Callback;
import com.sun.jna.Function;
import com.sun.jna.Pointer;
import com.sun.jna.ptr.PointerByReference;

/**
 * The <i>handler manager</i> is used to attach diagnostic handlers to the Vulkan instance.
 * <p>
 * Handlers are configured and attached to the instance using the {@link #builder()}.
 * <p>
 * Notes:
 * <ul>
 * <li>Handlers are released when the instance itself is destroyed</li>
 * <li>In general it is expected that a single handler will be sufficient for most or all application requirements, however the API does support multiple handlers</li>
 * <li>Diagnostics messages can contain an arbitrary pointer to a <i>user data</i> object but this is assumed to be redundant for an OO implementation and is always {@code null}</li>
 * </ul>
 * @author Sarge
 */
public class HandlerManager {
	private final Instance instance;
	private final Supplier<Function> create, destroy;
	private final Collection<Handler> handlers = new ArrayList<>();

	/**
	 * Constructor.
	 * @param instance Parent instance
	 */
	HandlerManager(Instance instance) {
		this.instance = notNull(instance);
		this.create = function("vkCreateDebugUtilsMessengerEXT");
		this.destroy = function("vkDestroyDebugUtilsMessengerEXT");
	}

	/**
	 * Helper - Creates a lazy supplier for a handler API method.
	 */
	private Supplier<Function> function(String name) {
		return new LazySupplier<>(() -> instance.function(name));
	}

	/**
	 * @return Attached handlers
	 */
	public Stream<Handler> handlers() {
		return handlers.stream();
	}

	/**
	 * @return New builder for a handler
	 */
	public Builder builder() {
		return new Builder();
	}

	/**
	 * Releases all attached handlers.
	 */
	public synchronized void close() {
		List.copyOf(handlers).forEach(Handler::destroy);
		assert handlers.isEmpty();
	}

	@Override
	public String toString() {
		return new ToStringBuilder(this).append("handlers", handlers.size()).build();
	}

	/**
	 * A <i>message</i> is a diagnostics report generated by Vulkan.
	 */
	public record Message(VkDebugUtilsMessageSeverity severity, Collection<VkDebugUtilsMessageType> types, VkDebugUtilsMessengerCallbackData data) {
		/**
		 * Constructor.
		 * @param severity		Severity
		 * @param types			Message type(s)
		 * @param data			Message data
		 */
		public Message {
			Check.notNull(severity);
			Check.notEmpty(types);
			Check.notNull(data);
		}

		/**
		 * Constructs a string representation of this message.
		 * <p>
		 * The message text is a colon-delimited string comprised of the following elements:
		 * <ul>
		 * <li>severity</li>
		 * <li>type(s) separated by the hyphen character</li>
		 * <li>message identifier</li>
		 * <li>message text</li>
		 * </ul>
		 * Example:
		 * <code>ERROR:VALIDATION-GENERAL:1234:message</code>
		 * <p>
		 * @return Message text
		 */
		@Override
		public String toString() {
			final String compoundTypes = types.stream().map(Enum::name).collect(joining("-"));
			final StringJoiner str = new StringJoiner(":");
			str.add(severity.name());
			str.add(compoundTypes);
			if(!data.pMessage.contains(data.pMessageIdName)) {
				str.add(data.pMessageIdName);
			}
			str.add(data.pMessage);
			return str.toString();
		}
	}

	/**
	 * Message callback.
	 * <p>
	 * Notes:
	 * <ul>
	 * <li>A JNA callback <b>must</b> implement a <b>single</b> method (though this is not enforced at compile-time)</li>
	 * <li>The signature of the callback is not part of the public Vulkan API</li>
	 * <li>Diagnostics messages can contain an arbitrary pointer to a <i>user data</i> object but this is assumed to be redundant for an OO implementation and is always {@code null}</li>
	 * <li>TODO - link to VK doc</li>
	 * </ul>
	 */
	static class MessageCallback implements Callback {
		private final Consumer<Message> consumer;

		MessageCallback(Consumer<Message> consumer) {
			this.consumer = consumer;
		}

		/**
		 * Callback handler method.
		 * @param severity			Severity
		 * @param type				Message type(s) mask
		 * @param pCallbackData		Data
		 * @param pUserData			Optional user data (always {@code null})
		 * @return Whether to continue execution (always {@code false})
		 */
		public boolean message(int severity, int type, VkDebugUtilsMessengerCallbackData pCallbackData, Pointer pUserData) {
			// Transform bit-masks to enumerations
			final VkDebugUtilsMessageSeverity severityEnum = IntegerEnumeration.mapping(VkDebugUtilsMessageSeverity.class).map(severity);
			final Collection<VkDebugUtilsMessageType> typesEnum = IntegerEnumeration.mapping(VkDebugUtilsMessageType.class).enumerate(type);

			// Create message wrapper
			final Message message = new Message(severityEnum, typesEnum, pCallbackData);

			// Delegate to handler
			consumer.accept(message);

			// Continue execution
			return false;
		}
	}

	/**
	 * A <i>handler</i> is a diagnostics message handler attached to the instance.
	 */
	public class Handler extends AbstractTransientNativeObject {
		/**
		 * Constructor.
		 * @param handle Handle
		 */
		private Handler(Pointer handle) {
			super(handle);
		}

		@Override
		protected void release() {
			// Destroy handler
			final Pointer parent = instance.handle().toPointer();
			final Object[] args = {parent, handle.toPointer(), null};
			destroy.get().invoke(args);

			// Remove handler
			assert handlers.contains(this);
			handlers.remove(this);
		}
	}

	/**
	 * Builder for a diagnostics message {@link Handler}.
	 * <p>
	 * Usage:
	 * <pre>
	 *  HandlerManager manager = instance.manager();
	 *  Consumer consumer = ...
	 *
	 *  // Attach handler
	 *  Handler handler = manager
	 *  	.builder()
	 *  	.severity(VkDebugUtilsMessageSeverity.WARNING)
	 *  	.severity(VkDebugUtilsMessageSeverity.ERROR)
	 *  	.type(VkDebugUtilsMessageType.GENERAL)
	 *  	.type(VkDebugUtilsMessageType.VALIDATION)
	 *  	.consumer(consumer)
	 *  	.build();
	 *
	 *  // Alternatively
	 *  manager
	 *  	.builder()
	 *  	.init()
	 *  	.build();
	 * </pre>
	 */
	public class Builder {
		private final Set<VkDebugUtilsMessageSeverity> severity = new HashSet<>();
		private final Set<VkDebugUtilsMessageType> types = new HashSet<>();
		private Consumer<Message> consumer = System.err::println;

		/**
		 * Sets the message consumer (dumps messages to the error console by default).
		 * @param consumer Message consumer
		 */
		public Builder consumer(Consumer<Message> consumer) {
			this.consumer = notNull(consumer);
			return this;
		}

		/**
		 * Adds a message severity to be reported by this handler.
		 * @param severity Message severity
		 */
		public Builder severity(VkDebugUtilsMessageSeverity severity) {
			this.severity.add(notNull(severity));
			return this;
		}

		/**
		 * Adds a message type to be reported by this handler.
		 * @param type Message type
		 */
		public Builder type(VkDebugUtilsMessageType type) {
			types.add(notNull(type));
			return this;
		}

		/**
		 * Convenience method - Initialises this builder to the following defaults:
		 * <ul>
		 * <li>warnings and higher</li>
		 * <li>general or validation message types</li>
		 * </ul>
		 */
		public Builder init() {
			severity(VkDebugUtilsMessageSeverity.WARNING);
			severity(VkDebugUtilsMessageSeverity.ERROR);
			type(VkDebugUtilsMessageType.GENERAL);
			type(VkDebugUtilsMessageType.VALIDATION);
			return this;
		}

		/**
		 * Builds and attaches this handler.
		 * @throws IllegalArgumentException if the message severities or types is empty
		 */
		public Handler build() {
			// Validate
			if(severity.isEmpty()) throw new IllegalArgumentException("No message severities specified");
			if(types.isEmpty()) throw new IllegalArgumentException("No message types specified");

			// Build handler descriptor
			final var info = new VkDebugUtilsMessengerCreateInfoEXT();
			info.messageSeverity = IntegerEnumeration.mask(severity);
			info.messageType = IntegerEnumeration.mask(types);
			info.pfnUserCallback = new MessageCallback(consumer);
			info.pUserData = null;

			// Register handler with instance
			final Pointer parent = instance.handle().toPointer();
			final PointerByReference ref = instance.factory().pointer();
			final Object[] args = {parent, info, null, ref};
			check(create.get().invokeInt(args));

			// Create handler
			final Handler handler = new Handler(ref.getValue());
			handlers.add(handler);

			return handler;
		}
	}
}
