package org.sarge.jove.platform.vulkan.core;

import static java.lang.foreign.ValueLayout.*;
import static java.util.Objects.requireNonNull;
import static java.util.stream.Collectors.joining;

import java.lang.foreign.*;
import java.lang.invoke.*;
import java.util.*;
import java.util.function.*;

import org.sarge.jove.common.*;
import org.sarge.jove.foreign.*;
import org.sarge.jove.platform.vulkan.*;
import org.sarge.jove.util.*;

/**
 * A <i>diagnostic handler</i> is a listener for Vulkan diagnostic messages.
 * @author Sarge
 */
public class DiagnosticHandler extends TransientNativeObject {
	/**
	 * Debug utility extension name.
	 */
	public static final String EXTENSION = "VK_EXT_debug_utils";

	private final Instance instance;

	/**
	 * Constructor.
	 * @param handle 		Handle
	 * @param instance		Parent instance
	 */
	DiagnosticHandler(Handle handle, Instance instance) {
		super(handle);
		this.instance = requireNonNull(instance);
	}

	/**
	 * Creates the diagnostic handler.
	 * @param info			Handler descriptor
	 * @param instance		Parent instance
	 * @return Diagnostic handler
	 */
	private static Handle create(VkDebugUtilsMessengerCreateInfoEXT info, Instance instance) {
		// Lookup create function pointer
		final Handle function = instance.function("vkCreateDebugUtilsMessengerEXT");

		// Build native method
		final var registry = instance.vulkan().registry();
		final var factory = new NativeMethod.Factory(registry);
		final Class<?>[] signature = {Instance.class, VkDebugUtilsMessengerCreateInfoEXT.class, Handle.class, NativeReference.class};
		final NativeMethod create = factory.build(function.address(), MethodType.methodType(int.class, signature));

		// Create handler
		final NativeReference<Handle> ref = instance.vulkan().factory().pointer();
		final Object[] args = {instance, info, null, ref};
		Vulkan.check((int) create.invoke(args));

		// Extract handler address
		return ref.get();
	}

	@Override
	protected void release() {
		// Lookup destructor function
		final Handle function = instance.function("vkDestroyDebugUtilsMessengerEXT");

		// Build native method
		final var registry = instance.vulkan().registry();
		final var factory = new NativeMethod.Factory(registry);
		final Class<?>[] signature = {Instance.class, DiagnosticHandler.class, Handle.class};
		final NativeMethod destroy = factory.build(function.address(), MethodType.methodType(void.class, signature));

		// Destroy handler
		final Object[] args = {instance, this, null};
		destroy.invoke(args);
	}

	/**
	 * A <i>message</i> is a diagnostics report generated by Vulkan.
	 */
	public record Message(VkDebugUtilsMessageSeverity severity, Set<VkDebugUtilsMessageType> types, VkDebugUtilsMessengerCallbackData data) {
		/**
		 * Constructs the string representation of this message.
		 * <p>
		 * The message text is a colon-delimited string comprising the following elements:
		 * <ul>
		 * <li>severity</li>
		 * <li>type(s) separated by the hyphen character</li>
		 * <li>identifier</li>
		 * <li>text</li>
		 * </ul>
		 * Example: {@code ERROR:VALIDATION-GENERAL:1234:message}
		 * <p>
		 * @return Message text
		 */
		@Override
		public String toString() {
			final var str = new StringJoiner(":");
			str.add(severity.name());
			str.add(compoundTypes());
			if(!data.pMessage.contains(data.pMessageIdName)) {
				str.add(data.pMessageIdName);
			}
			str.add(data.pMessage);
			return str.toString();
		}

		private String compoundTypes() {
			return types
					.stream()
					.sorted()
					.map(Enum::name)
					.collect(joining("-"));
		}
	}

	/**
	 * Message callback.
	 * Note that the callback signature is not defined in the Vulkan API.
	 * @see <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/PFN_vkDebugUtilsMessengerCallbackEXT.html">Vulkan documentation</a>
	 */
	private record Callback(Consumer<Message> consumer, Function<MemorySegment, NativeStructure> unmarshal) {
		/**
		 * Callback handler method.
		 * @param severity			Severity
		 * @param type				Message type(s) bitfield
		 * @param pCallbackData		Data
		 * @param pUserData			Optional user data (always {@code null})
		 * @return {@code false}
		 */
		@SuppressWarnings("unused")
		public boolean message(int severity, int typeMask, MemorySegment pCallbackData, MemorySegment pUserData) {
			// Unmarshal message properties
			final var types = new EnumMask<VkDebugUtilsMessageType>(typeMask).enumerate(VkDebugUtilsMessageType.class);
			final var level = IntEnum.reverse(VkDebugUtilsMessageSeverity.class).map(severity);

			// Unmarshal diagnostic report
			final var data = (VkDebugUtilsMessengerCallbackData) unmarshal.apply(pCallbackData);

			// Handle message
			final Message message = new Message(level, types, data);
			consumer.accept(message);

			return false;
		}

		/**
		 * @return Upcall stub for this callback
		 */
		public MemorySegment address() {
			try {
				// Lookup callback method and bind to handler
				final Class<?>[] signature = {int.class, int.class, MemorySegment.class, MemorySegment.class};
				final var type = MethodType.methodType(boolean.class, signature);
	    		final MethodHandle handle = MethodHandles.lookup().findVirtual(Callback.class, "message", type).bindTo(this);

	    		// Link upcall stub
				final MemoryLayout[] layout = {JAVA_INT, JAVA_INT, ADDRESS, ADDRESS};
	    		final var descriptor = FunctionDescriptor.of(JAVA_BOOLEAN, layout);
	   			return Linker.nativeLinker().upcallStub(handle, descriptor, Arena.ofAuto());
			}
			catch(Exception e) {
				throw new RuntimeException("Error instantiating diagnostic callback", e);
			}
		}
	}

	/**
	 * Builder for a diagnostics handler.
	 * <p>
	 * Notes:
	 * <ul>
	 * <li>If not explicitly configured the severity and types are initialised to default values</li>
	 * <li>The default message consumer dumps diagnostic reports to the error console</li>
	 * </ul>
	 */
	public static class Builder {
		private final Set<VkDebugUtilsMessageSeverity> severity = new HashSet<>();
		private final Set<VkDebugUtilsMessageType> types = new HashSet<>();
		private Consumer<Message> consumer = System.err::println;

		/**
		 * Sets the message consumer.
		 * @param consumer Message consumer
		 */
		public Builder consumer(Consumer<Message> consumer) {
			this.consumer = requireNonNull(consumer);
			return this;
		}

		/**
		 * Adds a message severity to be reported by this handler.
		 * @param severity Message severity
		 */
		public Builder severity(VkDebugUtilsMessageSeverity severity) {
			this.severity.add(severity);
			return this;
		}

		/**
		 * Adds a message type to be reported by this handler.
		 * @param type Message type
		 */
		public Builder type(VkDebugUtilsMessageType type) {
			types.add(type);
			return this;
		}

		/**
		 * Builds this handler and attaches it to the given instance.
		 */
		public void attach(Instance instance) {
			final NativeStructureTransformer transformer = transformer(instance);
			final var callback = new Callback(consumer, transformer.unmarshal());
			final VkDebugUtilsMessengerCreateInfoEXT info = populate(callback);
			final Handle handle = create(info, instance);
    		final var handler = new DiagnosticHandler(handle, instance);
    		instance.attach(handler);
		}

		/**
		 * Creates the diagnostic structure transformer.
		 */
		private static NativeStructureTransformer transformer(Instance instance) {
			final var registry = instance.vulkan().registry();
			final var factory = NativeStructureTransformer.factory(registry);
			return (NativeStructureTransformer) factory.create(VkDebugUtilsMessengerCallbackData.class);
		}

		/**
		 * Initialises the message configuration to default values if not provided.
		 */
		private void init() {
			if(severity.isEmpty()) {
				severity(VkDebugUtilsMessageSeverity.WARNING);
				severity(VkDebugUtilsMessageSeverity.ERROR);
			}

			if(types.isEmpty()) {
				type(VkDebugUtilsMessageType.GENERAL);
				type(VkDebugUtilsMessageType.VALIDATION);
			}
		}

		/**
		 * Builds the create descriptor for this handler.
		 * @param callback Callback handler
		 */
		private VkDebugUtilsMessengerCreateInfoEXT populate(Callback callback) {
			final var info = new VkDebugUtilsMessengerCreateInfoEXT();
			init();
			info.messageSeverity = new EnumMask<>(severity);
			info.messageType = new EnumMask<>(types);
			info.pfnUserCallback = new Handle(callback.address());
			info.pUserData = null;
			return info;
		}
	}
}
