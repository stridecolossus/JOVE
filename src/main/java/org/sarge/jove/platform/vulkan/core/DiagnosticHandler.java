package org.sarge.jove.platform.vulkan.core;

import static java.lang.foreign.ValueLayout.*;
import static java.util.Objects.requireNonNull;
import static java.util.stream.Collectors.joining;

import java.lang.foreign.*;
import java.lang.invoke.*;
import java.util.*;
import java.util.function.*;

import org.sarge.jove.common.*;
import org.sarge.jove.foreign.*;
import org.sarge.jove.foreign.NativeReference.Pointer;
import org.sarge.jove.platform.vulkan.*;
import org.sarge.jove.util.EnumMask;
import org.sarge.jove.util.IntEnum.ReverseMapping;

/**
 * A <i>diagnostic handler</i> is a listener for Vulkan diagnostic messages.
 * @author Sarge
 */
public class DiagnosticHandler extends TransientNativeObject {
	/**
	 * Debug utility extension name.
	 */
	public static final String EXTENSION = "VK_EXT_debug_utils";

	/**
	 *
	 */
	private interface HandlerLibrary {
		/**
		 * Creates a diagnostic handler.
		 * @param instance			Parent instance
		 * @param pCreateInfo		Descriptor
		 * @param pAllocator		Allocator
		 * @param pHandler			Returned handler
		 * @return Result
		 */
		VkResult vkCreateDebugUtilsMessengerEXT(Instance instance, VkDebugUtilsMessengerCreateInfoEXT pCreateInfo, Handle pAllocator, Pointer pHandler);

		/**
		 * Destroys a diagnostic handler.
		 * @param instance			Parent instance
		 * @param handler			Handler to destroy
		 * @param pAllocator		Allocator
		 */
		void vkDestroyDebugUtilsMessengerEXT(Instance instance, DiagnosticHandler handler, Handle pAllocator);
	}

	private final Instance instance;
	private final HandlerLibrary lib;

	/**
	 * Constructor.
	 * @param handle 		Handle
	 * @param instance		Parent instance
	 * @param lib			Library
	 */
	DiagnosticHandler(Handle handle, Instance instance, HandlerLibrary lib) {
		super(handle);
		this.instance = requireNonNull(instance);
		this.lib = requireNonNull(lib);
	}

//	/**
//	 * Creates the diagnostic handler.
//	 * @param info			Handler descriptor
//	 * @param instance		Parent instance
//	 * @return Diagnostic handler
//	 * @throws IllegalArgumentException if the function pointer for diagnostic handlers cannot be found
//	 * @throws VulkanException if the handler cannot be created
//	 */
//	private static Handle create(VkDebugUtilsMessengerCreateInfoEXT info, Instance instance) {
//		// Lookup create function pointer
//		final Handle function = instance.function("vkCreateDebugUtilsMessengerEXT");
//
//		// Build native method
//		final var create = new NativeMethod.Builder(DefaultRegistry.create())
//				.address(function.address())
//				.returns(VkResult.class)
//				.parameter(Instance.class)
//				.parameter(VkDebugUtilsMessengerCreateInfoEXT.class)
//				.parameter(Handle.class)
//				.parameter(NativeReference.class)
//				.build();
//
//		// Create handler
//		final var ref = new Pointer();
//		final Object[] args = {instance, info, null, ref};
//		final VkResult result = (VkResult) create.invoke(args);
//		if(result != VkResult.SUCCESS) throw new VulkanException(result);
//
//		// Extract handler address
//		return ref.get();
//	}

	@Override
	protected void release() {
		/*
		// Lookup destructor
		final Handle function = instance.function("vkDestroyDebugUtilsMessengerEXT");

		// Build destroy method
		final NativeMethod destroy = new NativeMethod.Builder(DefaultRegistry.create())
				.address(function.address())
				.parameter(Instance.class)
				.parameter(DiagnosticHandler.class)
				.parameter(Handle.class)
				.build();

		// Destroy handler
		final Object[] args = {instance, this, null};
		destroy.invoke(args);
		*/
		lib.vkDestroyDebugUtilsMessengerEXT(instance, this, null);
	}

	/**
	 * A <i>message</i> is a diagnostics report generated by Vulkan.
	 */
	public record Message(VkDebugUtilsMessageSeverity severity, Set<VkDebugUtilsMessageType> types, VkDebugUtilsMessengerCallbackData data) {
		/**
		 * Constructs the string representation of this message.
		 * <p>
		 * The message text is a colon-delimited string comprising the following elements:
		 * <ul>
		 * <li>severity</li>
		 * <li>type(s) separated by the hyphen character</li>
		 * <li>identifier</li>
		 * <li>text</li>
		 * </ul>
		 * Example: {@code ERROR:VALIDATION-GENERAL:1234:message}
		 * <p>
		 * @return Message text
		 */
		@Override
		public String toString() {
			final var str = new StringJoiner(":");
			str.add(severity.name());
			str.add(compoundTypes());
			if(!data.pMessage.contains(data.pMessageIdName)) {
				str.add(data.pMessageIdName);
			}
			str.add(data.pMessage);
			return str.toString();
		}

		private String compoundTypes() {
			return types
					.stream()
					.sorted()
					.map(Enum::name)
					.collect(joining("-"));
		}
	}

	/**
	 * Message callback.
	 * Note that the callback signature is not defined in the Vulkan API.
	 * @see <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/PFN_vkDebugUtilsMessengerCallbackEXT.html">Vulkan documentation</a>
	 */
	private record Callback(Consumer<Message> consumer, DefaultTransformer<NativeStructure> transformer) {
		private static final ReverseMapping<VkDebugUtilsMessageType> TYPE = new ReverseMapping<>(VkDebugUtilsMessageType.class);
		private static final ReverseMapping<VkDebugUtilsMessageSeverity> SEVERITY = new ReverseMapping<>(VkDebugUtilsMessageSeverity.class);

		/**
		 * Callback handler method.
		 * @param severity			Severity
		 * @param type				Message type(s) bitfield
		 * @param pCallbackData		Data
		 * @param pUserData			Optional user data (always {@code null})
		 * @return {@code false}
		 */
		@SuppressWarnings({"unused", "rawtypes", "unchecked"})
		public boolean message(int severity, int typeMask, MemorySegment pCallbackData, MemorySegment pUserData) {
			// Unmarshal message properties
			final var types = new EnumMask<VkDebugUtilsMessageType>(typeMask).enumerate(TYPE);
			final var level = SEVERITY.map(severity);

			// Unmarshal diagnostic report
			final MemorySegment address = pCallbackData.reinterpret(transformer.layout().byteSize());
			final Function function = transformer.unmarshal();
			final var data = (VkDebugUtilsMessengerCallbackData) function.apply(address);

			// Handle message
			final Message message = new Message(level, types, data);
			consumer.accept(message);

			return false;
		}

		/**
		 * @return Upcall stub for this callback
		 */
		MemorySegment address() throws Exception {
			// Lookup callback method and bind to handler
			final Class<?>[] signature = {int.class, int.class, MemorySegment.class, MemorySegment.class};
			final var type = MethodType.methodType(boolean.class, signature);
    		final MethodHandle handle = MethodHandles.lookup().findVirtual(Callback.class, "message", type).bindTo(this);

    		// Link upcall stub
			final MemoryLayout[] layout = {JAVA_INT, JAVA_INT, ADDRESS, ADDRESS};
    		final var descriptor = FunctionDescriptor.of(JAVA_BOOLEAN, layout);
    		final var linker = Linker.nativeLinker();
   			return linker.upcallStub(handle, descriptor, Arena.ofAuto());
		}
	}

	/**
	 * Builder for a diagnostics handler.
	 * <p>
	 * Notes:
	 * <ul>
	 * <li>If not explicitly configured the severity and types are initialised to default values</li>
	 * <li>The default message consumer dumps diagnostic reports to the error console</li>
	 * </ul>
	 */
	public static class Builder {
		private final Registry registry = DefaultRegistry.create(); // TODO - is full registry really needed here? int/String/Handle required
		private final Set<VkDebugUtilsMessageSeverity> severity = new HashSet<>();
		private final Set<VkDebugUtilsMessageType> types = new HashSet<>();
		private Consumer<Message> consumer = System.err::println;

		/**
		 * Sets the message consumer.
		 * @param consumer Message consumer
		 */
		public Builder consumer(Consumer<Message> consumer) {
			this.consumer = requireNonNull(consumer);
			return this;
		}

		/**
		 * Adds a message severity to be reported by this handler.
		 * @param severity Message severity
		 */
		public Builder severity(VkDebugUtilsMessageSeverity severity) {
			this.severity.add(severity);
			return this;
		}

		/**
		 * Adds a message type to be reported by this handler.
		 * @param type Message type
		 */
		public Builder type(VkDebugUtilsMessageType type) {
			types.add(type);
			return this;
		}

		/**
		 * Constructs this handler.
		 * @param instance Parent instance
		 * @return Diagnostic handler
		 */
		public DiagnosticHandler build(Instance instance) {
			// Init configuration
			init();

			// Create callback method
			final MemorySegment callback = callback();

			// Build descriptor
			final VkDebugUtilsMessengerCreateInfoEXT info = populate(callback);

			// Create handler
			return create(info, instance);
		}

		/**
		 * Initialises the message configuration to default values if not provided.
		 */
		private void init() {
			if(severity.isEmpty()) {
				severity(VkDebugUtilsMessageSeverity.WARNING);
				severity(VkDebugUtilsMessageSeverity.ERROR);
			}

			if(types.isEmpty()) {
				type(VkDebugUtilsMessageType.GENERAL);
				type(VkDebugUtilsMessageType.VALIDATION);
			}
		}

		/**
		 * Builds the create descriptor for this handler.
		 * @param callback Callback handler
		 */
		private VkDebugUtilsMessengerCreateInfoEXT populate(MemorySegment callback) {
			final var info = new VkDebugUtilsMessengerCreateInfoEXT();
			info.messageSeverity = new EnumMask<>(severity);
			info.messageType = new EnumMask<>(types);
			info.pfnUserCallback = new Handle(callback);
			info.pUserData = null;
			return info;
		}

		/**
		 * Creates the message callback.
		 * @param registry Transformer registry
		 * @return Callback address
		 */
		private MemorySegment callback() {
			// Create a transformer for diagnostic messages
			@SuppressWarnings("unchecked")
			final var transformer = (DefaultTransformer<NativeStructure>) registry.transformer(VkDebugUtilsMessengerCallbackData.class).orElseThrow();

			// Instantiate the callback
			final var callback = new Callback(consumer, transformer);

			// Determine address
			try {
				return callback.address();
			}
			catch(Exception e) {
				throw new RuntimeException("Error instantiating diagnostic callback", e);
			}
		}

		/**
		 * Instantiates the diagnostic handler.
		 * @param info			Descriptor
		 * @param instance		Parent instance
		 * @return New handler
		 */
		private DiagnosticHandler create(VkDebugUtilsMessengerCreateInfoEXT info, Instance instance) {
			// Lookup function pointers from the instance
			final SymbolLookup lookup = name -> instance.function(name).map(Handle::address);

			// Create diagnostics library
			final var factory = new NativeLibraryFactory(lookup, registry);
			final var lib = factory.build(HandlerLibrary.class);

			// Instantiate handler
			final var handle = new Pointer();
			lib.vkCreateDebugUtilsMessengerEXT(instance, info, null, handle);

			// Create handler
			return new DiagnosticHandler(handle.get(), instance, lib);
		}
	}
}
