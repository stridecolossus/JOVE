package org.sarge.jove.platform.vulkan.core;

import static java.lang.foreign.ValueLayout.*;
import static java.util.Objects.requireNonNull;
import static java.util.stream.Collectors.joining;

import java.lang.foreign.*;
import java.lang.invoke.*;
import java.util.*;
import java.util.function.Consumer;

import org.sarge.jove.common.*;
import org.sarge.jove.foreign.*;
import org.sarge.jove.platform.vulkan.*;
import org.sarge.jove.platform.vulkan.common.VulkanException;
import org.sarge.jove.util.EnumMask;
import org.sarge.jove.util.IntEnum.ReverseMapping;

/**
 * A <i>diagnostic handler</i> is a listener for Vulkan diagnostic messages.
 * @author Sarge
 */
public class DiagnosticHandler extends TransientNativeObject {
	/**
	 * Debug utility extension name.
	 */
	public static final String EXTENSION = "VK_EXT_debug_utils";

	/**
	 * Diagnostic hander library.
	 */
	interface HandlerLibrary {
		/**
		 * Creates a diagnostic handler.
		 * @param instance			Parent instance
		 * @param pCreateInfo		Descriptor
		 * @param pAllocator		Allocator
		 * @param pHandler			Returned handler
		 * @return Result
		 */
		VkResult vkCreateDebugUtilsMessengerEXT(Instance instance, VkDebugUtilsMessengerCreateInfoEXT pCreateInfo, Handle pAllocator, Pointer pHandler);

		/**
		 * Destroys a diagnostic handler.
		 * @param instance			Parent instance
		 * @param handler			Handler to destroy
		 * @param pAllocator		Allocator
		 */
		void vkDestroyDebugUtilsMessengerEXT(Instance instance, DiagnosticHandler handler, Handle pAllocator);
	}

	private final Instance instance;
	private final HandlerLibrary library;

	/**
	 * Constructor.
	 * @param handle 		Handle
	 * @param instance		Parent instance
	 * @param lib			Library
	 */
	DiagnosticHandler(Handle handle, Instance instance, HandlerLibrary lib) {
		super(handle);
		this.instance = requireNonNull(instance);
		this.library = requireNonNull(lib);
	}

	@Override
	protected void release() {
		library.vkDestroyDebugUtilsMessengerEXT(instance, this, null);
	}

	/**
	 * A <i>message</i> is a diagnostics report generated by Vulkan.
	 */
	public record Message(VkDebugUtilsMessageSeverity severity, Set<VkDebugUtilsMessageType> types, VkDebugUtilsMessengerCallbackData data) {
		/**
		 * Constructs the string representation of this message.
		 * <p>
		 * The message text is a colon-delimited string comprising the following elements:
		 * <ul>
		 * <li>severity</li>
		 * <li>type(s) separated by the hyphen character</li>
		 * <li>identifier</li>
		 * <li>text</li>
		 * </ul>
		 * Example: {@code ERROR:VALIDATION-GENERAL:1234:message}
		 * <p>
		 * @return Message text
		 */
		@Override
		public String toString() {
			final var str = new StringJoiner(":");
			str.add(severity.name());
			str.add(compoundTypes());
			if(!data.pMessage.contains(data.pMessageIdName)) {
				str.add(data.pMessageIdName);
			}
			str.add(data.pMessage);
			return str.toString();
		}

		private String compoundTypes() {
			return types
					.stream()
					.sorted()
					.map(Enum::name)
					.collect(joining("-"));
		}
	}

	/**
	 * Message callback.
	 * Note that the callback signature is not defined in the Vulkan API.
	 * @see <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/PFN_vkDebugUtilsMessengerCallbackEXT.html">Vulkan documentation</a>
	 */
	@SuppressWarnings("rawtypes")
	private record Callback(Consumer<Message> consumer, Transformer transformer) {
		private static final ReverseMapping<VkDebugUtilsMessageType> TYPE = ReverseMapping.mapping(VkDebugUtilsMessageType.class);
		private static final ReverseMapping<VkDebugUtilsMessageSeverity> SEVERITY = ReverseMapping.mapping(VkDebugUtilsMessageSeverity.class);

		/**
		 * Callback handler method.
		 * @param severity			Severity
		 * @param type				Message type(s) bitfield
		 * @param pCallbackData		Data
		 * @param pUserData			Optional user data, always {@code null}
		 * @return {@code false}
		 */
		@SuppressWarnings({"unused", "unchecked"})
		public boolean message(int severity, int typeMask, MemorySegment pCallbackData, MemorySegment pUserData) {
			// Unmarshal message properties
			final var types = new EnumMask<VkDebugUtilsMessageType>(typeMask).enumerate(TYPE);
			final var level = SEVERITY.map(severity);

			// Unmarshal diagnostic report
			final MemorySegment address = pCallbackData.reinterpret(transformer.layout().byteSize());
			final var data = (VkDebugUtilsMessengerCallbackData) transformer.unmarshal().apply(address);

			// Handle message
			final Message message = new Message(level, types, data);
			consumer.accept(message);

			return false;
		}

		/**
		 * @return Upcall stub for this callback
		 */
		@SuppressWarnings("resource")
		MemorySegment address() throws Exception {
			// Lookup callback method and bind to handler
			final Class<?>[] signature = {int.class, int.class, MemorySegment.class, MemorySegment.class};
			final var type = MethodType.methodType(boolean.class, signature);
    		final MethodHandle handle = MethodHandles.lookup().findVirtual(Callback.class, "message", type).bindTo(this);

    		// Link upcall stub
			final MemoryLayout[] layout = {JAVA_INT, JAVA_INT, ADDRESS, ADDRESS};
    		final var descriptor = FunctionDescriptor.of(JAVA_BOOLEAN, layout);
    		final var linker = Linker.nativeLinker();
   			return linker.upcallStub(handle, descriptor, Arena.ofAuto());
		}
	}

	/**
	 * Builder for a diagnostics handler.
	 * <p>
	 * Notes:
	 * <ul>
	 * <li>If not explicitly configured the severity and types are initialised to default values</li>
	 * <li>The default message consumer dumps diagnostic reports to the error console</li>
	 * </ul>
	 */
	public static class Builder {
		private final Set<VkDebugUtilsMessageSeverity> severity = new HashSet<>();
		private final Set<VkDebugUtilsMessageType> types = new HashSet<>();
		private Consumer<Message> consumer = System.err::println;

		/**
		 * Sets the message consumer.
		 * @param consumer Message consumer
		 */
		public Builder consumer(Consumer<Message> consumer) {
			this.consumer = requireNonNull(consumer);
			return this;
		}

		/**
		 * Adds a message severity to be reported by this handler.
		 * @param severity Message severity
		 */
		public Builder severity(VkDebugUtilsMessageSeverity severity) {
			this.severity.add(severity);
			return this;
		}

		/**
		 * Adds a message type to be reported by this handler.
		 * @param type Message type
		 */
		public Builder type(VkDebugUtilsMessageType type) {
			types.add(type);
			return this;
		}

		/**
		 * Constructs this handler.
		 * @param instance		Parent instance
		 * @param registry		Transformer registry
		 * @return Diagnostic handler
		 */
		public DiagnosticHandler build(Instance instance, Registry registry) {
			// Initialise configuration
			init();

			// Create callback
			final MemorySegment callback = callback(registry);
			final VkDebugUtilsMessengerCreateInfoEXT info = populate(callback);

			// Create diagnostics library
			final HandlerLibrary lib = library(instance, registry);

			// Create handler
			final var handle = new Pointer();
			final VkResult result = lib.vkCreateDebugUtilsMessengerEXT(instance, info, null, handle);
			if(result != VkResult.SUCCESS) {
				throw new VulkanException(result);
			}

			// Create handler instance
			return new DiagnosticHandler(handle.get(), instance, lib);
		}

		/**
		 * Initialises the message configuration to default values if not provided.
		 */
		private void init() {
			if(severity.isEmpty()) {
				severity(VkDebugUtilsMessageSeverity.WARNING);
				severity(VkDebugUtilsMessageSeverity.ERROR);
			}
			if(types.isEmpty()) {
				type(VkDebugUtilsMessageType.GENERAL);
				type(VkDebugUtilsMessageType.VALIDATION);
			}
		}

		/**
		 * Creates the message callback.
		 * @param registry Transformer registry
		 * @return Callback address
		 * @throws NoSuchElementException if the transformer for the {@link VkDebugUtilsMessengerCallbackData} structure cannot be found
		 */
		private MemorySegment callback(Registry registry) {
			// Create a transformer for diagnostic messages
			final var transformer = registry.transformer(VkDebugUtilsMessengerCallbackData.class).orElseThrow();

			// Instantiate the callback
			final var callback = new Callback(consumer, transformer);

			// Determine address
			try {
				return callback.address();
			}
			catch(Exception e) {
				throw new RuntimeException("Error instantiating diagnostic callback", e);
			}
		}

		/**
		 * Builds the create descriptor for this handler.
		 * @param callback Callback handler
		 */
		private VkDebugUtilsMessengerCreateInfoEXT populate(MemorySegment callback) {
			final var info = new VkDebugUtilsMessengerCreateInfoEXT();
			info.messageSeverity = new EnumMask<>(severity);
			info.messageType = new EnumMask<>(types);
			info.pfnUserCallback = new Handle(callback);
			info.pUserData = null;
			return info;
		}

		/**
		 * Builds the diagnostic native library for the given instance.
		 * @param instance		Parent instance
		 * @param registry		Transformer registry
		 * @return Handler library
		 */
		protected HandlerLibrary library(Instance instance, Registry registry) {
			final SymbolLookup lookup = name -> instance.function(name).map(Handle::address);
	    	final var factory = new NativeLibraryFactory(lookup, registry);
	    	return (HandlerLibrary) factory.build(List.of(HandlerLibrary.class));
		}
	}
}
