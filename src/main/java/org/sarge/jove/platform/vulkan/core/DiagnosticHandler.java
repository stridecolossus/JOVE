package org.sarge.jove.platform.vulkan.core;

import static java.lang.foreign.ValueLayout.*;
import static java.util.Objects.requireNonNull;
import static java.util.stream.Collectors.joining;

import java.lang.foreign.*;
import java.lang.invoke.*;
import java.util.*;
import java.util.function.Consumer;

import org.sarge.jove.common.*;
import org.sarge.jove.foreign.*;
import org.sarge.jove.platform.vulkan.*;
import org.sarge.jove.platform.vulkan.common.VulkanException;
import org.sarge.jove.util.EnumMask;
import org.sarge.jove.util.IntEnum.ReverseMapping;

/**
 * A <i>diagnostic handler</i> is a listener for Vulkan diagnostic messages.
 * @see Vulkan#STANDARD_VALIDATION
 * @author Sarge
 */
public class DiagnosticHandler extends TransientNativeObject {
	/**
	 * Debug utility extension name.
	 */
	public static final String EXTENSION = "VK_EXT_debug_utils";

	/**
	 * Standard validation layer.
	 */
	public static final String STANDARD_VALIDATION = "VK_LAYER_KHRONOS_validation";

	/**
	 * Synthetic diagnostic hander library.
	 */
	interface HandlerLibrary {
		/**
		 * Creates a diagnostic handler.
		 * @param instance			Parent instance
		 * @param pCreateInfo		Descriptor
		 * @param pAllocator		Allocator
		 * @param pHandler			Returned handler
		 * @return Result
		 */
		VkResult vkCreateDebugUtilsMessengerEXT(Instance instance, VkDebugUtilsMessengerCreateInfoEXT pCreateInfo, Handle pAllocator, Pointer pHandler);

		/**
		 * Destroys a diagnostic handler.
		 * @param instance			Parent instance
		 * @param handler			Handler to destroy
		 * @param pAllocator		Allocator
		 */
		void vkDestroyDebugUtilsMessengerEXT(Instance instance, DiagnosticHandler handler, Handle pAllocator);
	}

	private final Instance instance;
	private final HandlerLibrary library;

	/**
	 * Constructor.
	 * @param handle 		Handle
	 * @param instance		Parent instance
	 * @param library		Diagnostic handler library
	 */
	DiagnosticHandler(Handle handle, Instance instance, HandlerLibrary library) {
		super(handle);
		this.instance = requireNonNull(instance);
		this.library = requireNonNull(library);
	}

	@Override
	protected void release() {
		library.vkDestroyDebugUtilsMessengerEXT(instance, this, null);
	}

	/**
	 * A <i>message</i> is a diagnostics report generated by Vulkan.
	 */
	public record Message(VkDebugUtilsMessageSeverityFlagsEXT severity, Set<VkDebugUtilsMessageTypeFlagsEXT> types, VkDebugUtilsMessengerCallbackDataEXT data) {
		/**
		 * Constructs the string representation of this message.
		 * <p>
		 * The message text is a colon-delimited string comprising the following elements:
		 * <ul>
		 * <li>severity</li>
		 * <li>type(s) separated by the hyphen character</li>
		 * <li>identifier</li>
		 * <li>text</li>
		 * </ul>
		 * Example: {@code ERROR:VALIDATION-GENERAL:1234:message}
		 * <p>
		 * @return Message text
		 */
		@Override
		public String toString() {
			final var str = new StringJoiner(":");
			str.add(clean(severity.name()));
			str.add(toString(types));
			if(!data.pMessage.contains(data.pMessageIdName)) {
				str.add(data.pMessageIdName);
			}
			str.add(data.pMessage);
			return str.toString();
		}

		/**
		 * @return Types a hyphen-delimited string
		 */
		private static String toString(Set<VkDebugUtilsMessageTypeFlagsEXT> types) {
			return types
					.stream()
					.sorted()
					.map(Enum::name)
					.map(Message::clean)
					.collect(joining("-"));
		}

		/**
		 * Strips trailing {@code EXT} suffix.
		 */
		private static String clean(String name) {
			final int index = name.indexOf("_EXT");
			if((index > 0) && (index == name.length() - 4)) {
				return name.substring(0, index);
			}
			else {
				return name;
			}
		}
	}

	/**
	 * Message callback.
	 */
	@SuppressWarnings("rawtypes")
	private record Callback(Consumer<Message> consumer, Transformer transformer) {
		private static final ReverseMapping<VkDebugUtilsMessageTypeFlagsEXT> TYPE = ReverseMapping.mapping(VkDebugUtilsMessageTypeFlagsEXT.class);
		private static final ReverseMapping<VkDebugUtilsMessageSeverityFlagsEXT> SEVERITY = ReverseMapping.mapping(VkDebugUtilsMessageSeverityFlagsEXT.class);

		/**
		 * Callback handler method.
		 * @param severity			Severity
		 * @param typeMask			Message type(s)
		 * @param pCallbackData		Data
		 * @param pUserData			Optional user data, always {@code null}
		 * @return {@code false}
		 */
		@SuppressWarnings({"unused", "unchecked"})
		public boolean message(int severity, int typeMask, MemorySegment pCallbackData, MemorySegment pUserData) {
			// Unmarshal message properties
			final var types = new EnumMask<VkDebugUtilsMessageTypeFlagsEXT>(typeMask).enumerate(TYPE);
			final var level = SEVERITY.map(severity);

			// Unmarshal diagnostic report
			final MemorySegment address = pCallbackData.reinterpret(transformer.layout().byteSize());
			final var data = (VkDebugUtilsMessengerCallbackDataEXT) transformer.unmarshal().apply(address);

			/**
			 *
			 * TODO
			 *
			 * this fails with code generated structure
			 * 3 x array fields unsupported!
			 *
			 * options (in order of effort / desirability):
			 * 1. custom structure layout with these fields as Handle (this works but requires manual fiddle)
			 * 2. custom layout with these fields omitted (unused anyway?)
			 * 3. 'manually' unmarshal from memory here
			 * 4. callback transformer mapper works differently (note currently does not do ANY mapping!)
			 * 5. complete revamp of transformers to somehow support returned arrays (hard)
			 *
			 */

			// Handle message
			final Message message = new Message(level, types, data);
			consumer.accept(message);

			return false;
		}

		/**
		 * @return Upcall stub for this callback
		 */
		@SuppressWarnings("resource")
		MemorySegment address() throws Exception {
			// Lookup callback method and bind to handler
			final Class<?>[] signature = {int.class, int.class, MemorySegment.class, MemorySegment.class};
			final var method = MethodType.methodType(boolean.class, signature);
    		final MethodHandle handle = MethodHandles.lookup().findVirtual(Callback.class, "message", method).bindTo(this);

    		// Link upcall stub
			final MemoryLayout[] layout = {JAVA_INT, JAVA_INT, ADDRESS, ADDRESS};
    		final var descriptor = FunctionDescriptor.of(JAVA_BOOLEAN, layout);
    		final var linker = Linker.nativeLinker();
   			return linker.upcallStub(handle, descriptor, Arena.global());
		}
		// TODO - integrate this with callback support (such as it is)? note callback returns a structure
	}

	/**
	 * Builder for a diagnostics handler.
	 * <p>
	 * Notes:
	 * <ul>
	 * <li>If not explicitly configured the severity and types are initialised to default values</li>
	 * <li>The default message consumer dumps diagnostic reports to the error console</li>
	 * </ul>
	 */
	public static class Builder {
		private final Set<VkDebugUtilsMessageSeverityFlagsEXT> severity = new HashSet<>();
		private final Set<VkDebugUtilsMessageTypeFlagsEXT> types = new HashSet<>();
		private Consumer<Message> consumer = System.err::println;

		/**
		 * Sets the message consumer.
		 * @param consumer Message consumer
		 */
		public Builder consumer(Consumer<Message> consumer) {
			this.consumer = requireNonNull(consumer);
			return this;
		}

		/**
		 * Adds a message severity to be reported by this handler.
		 * @param severity Message severity
		 */
		public Builder severity(VkDebugUtilsMessageSeverityFlagsEXT severity) {
			requireNonNull(severity);
			this.severity.add(severity);
			return this;
		}

		/**
		 * Adds a message type to be reported by this handler.
		 * @param type Message type
		 */
		public Builder type(VkDebugUtilsMessageTypeFlagsEXT type) {
			requireNonNull(type);
			types.add(type);
			return this;
		}

		/**
		 * Constructs this handler.
		 * @param instance		Parent instance
		 * @param registry		Transformer registry
		 * @return Diagnostic handler
		 */
		public DiagnosticHandler build(Instance instance, Registry registry) {
			// Initialise configuration
			init();

			// Create callback
			final MemorySegment callback = callback(registry);
			final VkDebugUtilsMessengerCreateInfoEXT info = populate(callback);

			// Create diagnostics library
			final HandlerLibrary library = library(instance, registry);

			// Create handler
			final var pointer = new Pointer();
			final VkResult result = library.vkCreateDebugUtilsMessengerEXT(instance, info, null, pointer);
			if(result != VkResult.VK_SUCCESS) {
				throw new VulkanException(result);
			}

			// Create handler instance
			return new DiagnosticHandler(pointer.handle(), instance, library);
		}

		/**
		 * Initialises the message configuration to default values if not provided.
		 */
		private void init() {
			if(severity.isEmpty()) {
				severity(VkDebugUtilsMessageSeverityFlagsEXT.WARNING_EXT);
				severity(VkDebugUtilsMessageSeverityFlagsEXT.ERROR_EXT);
			}
			if(types.isEmpty()) {
				type(VkDebugUtilsMessageTypeFlagsEXT.GENERAL_EXT);
				type(VkDebugUtilsMessageTypeFlagsEXT.VALIDATION_EXT);
			}
		}

		/**
		 * Creates the message callback.
		 * @param registry Transformer registry
		 * @return Callback address
		 * @throws NoSuchElementException if the transformer for the {@link VkDebugUtilsMessengerCallbackData} structure cannot be found
		 */
		private MemorySegment callback(Registry registry) {
			// Create a transformer for diagnostic messages
			final var transformer = registry.transformer(VkDebugUtilsMessengerCallbackDataEXT.class).orElseThrow();

			// Instantiate the callback
			final var callback = new Callback(consumer, transformer);

			// Determine address
			try {
				return callback.address();
			}
			catch(Exception e) {
				throw new RuntimeException("Error instantiating diagnostic callback", e);
			}
		}

		/**
		 * Builds the create descriptor for this handler.
		 * @param callback Callback handler
		 */
		private VkDebugUtilsMessengerCreateInfoEXT populate(MemorySegment callback) {
			final var info = new VkDebugUtilsMessengerCreateInfoEXT();
			info.sType = VkStructureType.DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT;
			info.messageSeverity = new EnumMask<>(severity);
			info.messageType = new EnumMask<>(types);
			info.pfnUserCallback = new Handle(callback);
			info.pUserData = null;
			return info;
		}

		/**
		 * Builds the diagnostic native library for the given instance.
		 * @param instance		Parent instance
		 * @param registry		Transformer registry
		 * @return Handler library
		 */
		protected HandlerLibrary library(Instance instance, Registry registry) {
			final SymbolLookup lookup = name -> instance.function(name).map(Handle::address);
	    	final var factory = new NativeLibraryFactory(lookup, registry);
	    	return (HandlerLibrary) factory.build(List.of(HandlerLibrary.class));
		}
	}
}
