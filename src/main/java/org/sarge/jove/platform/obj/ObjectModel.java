package org.sarge.jove.platform.obj;

import static org.sarge.jove.util.Check.notNull;

import java.util.ArrayList;
import java.util.Deque;
import java.util.LinkedList;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.function.Supplier;
import java.util.stream.Stream;

import org.apache.commons.lang3.builder.ToStringBuilder;
import org.sarge.jove.geometry.Point;
import org.sarge.jove.geometry.TextureCoordinate.Coordinate2D;
import org.sarge.jove.geometry.Vector;
import org.sarge.jove.model.Model;
import org.sarge.jove.model.Primitive;
import org.sarge.jove.model.Vertex;

/**
 * The <i>OBJ model</i> holds the transient vertex data during parsing and maintains the list of generated models.
 * <p>
 * TODO
 */
public class ObjectModel {
	/**
	 * A <i>component list</i> is a mutable list of vertex components.
	 * @param <T> Component type
	 */
	public static class ComponentList<T> {
		private final List<T> list = new ArrayList<>();

		/**
		 * @return Size of this list
		 */
		public int size() {
			return list.size();
		}

		/**
		 * Adds an object to this list.
		 * @param obj Object to add
		 */
		void add(T obj) {
			list.add(notNull(obj));
		}

		/**
		 * Retrieves an object from this list by index.
		 * @param index 1..n or negative from the end of the list
		 * @return Specified object
		 * @throws IndexOutOfBoundsException if the index is zero or is out-of-bounds for this list
		 */
		public T get(int index) {
			if(index > 0) {
				return list.get(index - 1);
			}
			else
			if(index < 0) {
				return list.get(list.size() + index);
			}
			else {
				throw new IndexOutOfBoundsException("Invalid zero index");
			}
		}

		@Override
		public String toString() {
			return String.valueOf(list.size());
		}
	}

	// Data
	private final ComponentList<Point> vertices = new ComponentList<>();
	private final ComponentList<Coordinate2D> coords = new ComponentList<>();
	private final ComponentList<Vector> normals = new ComponentList<>();

	// Models
	private final Supplier<Model.Builder> factory;
	private final Deque<Model.Builder> builders = new LinkedList<>();
	private boolean init;

	/**
	 * Constructor.
	 * @param factory Factory for the model builder
	 */
	public ObjectModel(Supplier<Model.Builder> factory) {
		this.factory = notNull(factory);
	}

	/**
	 * Constructor using a default model builder.
	 */
	public ObjectModel() {
		this(Model.Builder::new);
	}

	/**
	 * @return Vertices
	 */
	public ComponentList<Point> vertices() {
		return vertices;
	}

	/**
	 * @return Normals
	 */
	public ComponentList<Vector> normals() {
		return normals;
	}

	/**
	 * @return Texture coordinates
	 */
	public ComponentList<Coordinate2D> coordinates() {
		return coords;
	}

	/**
	 * @return Model builders
	 */
	public Stream<Model.Builder> builders() {
		return builders.stream();
	}

	/**
	 * Starts a new model.
	 * @throws NullPointerException if the factory returns a {@code null} model
	 */
	public void start() {
		// TODO - check previous model was 1. initialised and 2. contains some vertices

		// Create new builder
		final Model.Builder builder = factory.get();
		if(builder == null) {
			throw new NullPointerException("Null model generated by factory");
		}

		// Add un-initialised builder
		builders.add(builder);
		init = false;
	}

	/**
	 * @return Current model
	 * @throws IllegalStateException if the model has not been started
	 * @see #start()
	 */
	Model.Builder current() {
		if(builders.isEmpty()) throw new IllegalStateException("Model has not been started");
		return builders.getLast();
	}

	/**
	 * Initialises this model for a new face.
	 * @param size Number of face vertices
	 * @throws NoSuchElementException if the model has not been started
	 * @throws IllegalStateException if the given size does not match the existing model layout
	 */
	public void init(int size) {
		final Model.Builder builder = current();
		if(init) {
			// Verify face
			if(size != builder.primitive().size()) {
				throw new IllegalStateException(String.format("Face size mismatch: expected=%d actual=%d", builder.primitive().size(), size));
			}
		}
		else {
			// Initialise model
			builder.primitive(primitive(size));
			init(builder);
			init = true;
		}
	}

	/**
	 * @return Drawing primitive for the given number of face vertices
	 */
	private static Primitive primitive(int size) {
		return switch(size) {
			case 1 -> Primitive.POINTS;
			case 2 -> Primitive.LINES;
			case 3 -> Primitive.TRIANGLES;
			default -> throw new UnsupportedOperationException("Unsupported primitive size: " + size);
		};
	}
	// TODO - does OBJ only really support triangles?

	/**
	 * Initialises the model layout.
	 */
	private void init(Model.Builder builder) {
		final var layout = new ArrayList<Vertex.Component>();
		layout.add(Vertex.Component.POSITION);
		if(!normals.list.isEmpty()) {
			layout.add(Vertex.Component.NORMAL);
		}
		if(!coords.list.isEmpty()) {
			layout.add(Vertex.Component.TEXTURE_COORDINATE);
		}
		builder.layout(new Vertex.Layout(layout));
	}

	/**
	 * Adds a vertex to this model.
	 * @param vertex Vertex
	 * @throws NoSuchElementException if the model has not been started
	 * @throws IllegalStateException if the model has not been initialised
	 * @throws IllegalArgumentException if the vertex does not match the layout of this model
	 */
	public void add(Vertex vertex) {
		if(!init) throw new IllegalStateException("Model has not been initialised");
		final Model.Builder builder = current();
		builder.add(vertex);
	}

	@Override
	public String toString() {
		return new ToStringBuilder(this)
				.append("vertices", vertices)
				.append("normals", normals)
				.append("coords", coords)
				.append("models", builders.size())
				.build();
	}
}
