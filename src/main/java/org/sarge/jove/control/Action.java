package org.sarge.jove.control;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.StringJoiner;
import java.util.stream.Stream;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.builder.ToStringBuilder;
import org.sarge.jove.control.InputEvent.AbstractInputEventType;
import org.sarge.jove.control.InputEvent.Type;
import org.sarge.jove.util.Check;

/**
 * An <i>action</i> performs some operation in response to an {@link InputEvent}.
 * @author Sarge
 */
@FunctionalInterface
public interface Action<T extends Type> {
//	/**
//	 * Performs this action.
//	 * @param event Input event
//	 */
//	void execute(Button.Event button);
//	void execute(Position pos);
//	void execute(Axis.Event axis);

	void execute(InputEvent<T> event);

	/**
	 * An <i>action bindings</i> maps input events to actions.
	 */
	class Bindings { // implements InputEvent.Handler<? super Type> {
		private static final String DELIMITER = StringUtils.SPACE;

		private final Map<Action, Set<InputEvent.Type>> actions = new HashMap<>();
		private final Map<InputEvent.Type, Action> bindings = new HashMap<>();

		/**
		 * Adds an action to this set of bindings.
		 * @param action Action
		 * @throws IllegalArgumentException for a duplicate action
		 */
		public void add(Action action) {
			Check.notNull(action);
			if(actions.containsKey(action)) throw new IllegalArgumentException("Duplicate action: " + action);
			actions.put(action, new HashSet<>());
		}

		/**
		 * @return Actions in this set of bindings
		 */
		public Stream<Action> actions() {
			return actions.keySet().stream();
		}

		/**
		 * Helper - Looks up the bindings for the given action.
		 * @param action Action
		 * @return Bindings
		 */
		private Set<InputEvent.Type> get(Action action) {
			final var bindings = actions.get(action);
			if(bindings == null) throw new IllegalArgumentException("Action not present: " + action);
			return bindings;
		}

		/**
		 * Looks up all events bound to the given action.
		 * @param action Action
		 * @return Input events bound to the given action
		 * @throws IllegalArgumentException if the action is not present in this set of bindings
		 */
		public Stream<InputEvent.Type> bindings(Action action) {
			return get(action).stream();
		}

		/**
		 * Looks up the action bound to an event.
		 * @param type Input type
		 * @return Action
		 */
		public Optional<Action> binding(InputEvent.Type type) {
			return Optional.ofNullable(bindings.get(type));
		}

		/**
		 * Binds an input event to the given action.
		 * @param type			Input event
		 * @param action		Action
		 * @throws IllegalStateException if the event is already bound
		 */
		public void bind(InputEvent.Type type, Action action) {
			Check.notNull(type);
			if(bindings.containsKey(type)) throw new IllegalArgumentException("Event is already bound: " + type);

			actions.computeIfAbsent(action, ignored -> new HashSet<>()).add(type);
			bindings.put(type, action);
		}

//		public <T extends Type> void bind(T type, InputEvent.Handler<T> handler) {
//		}

		/**
		 * Removes the binding for the given type of event.
		 * @param type Event type
		 */
		public void remove(InputEvent.Type type) {
			final Action action = bindings.remove(type);
			if(action != null) {
				actions.get(action).remove(type);
			}
		}

		/**
		 * Removes <b>all</b> bindings for the given action.
		 * @param action Action
		 * @throws IllegalArgumentException if the action is not present
		 */
		public void remove(Action action) {
			final var set = get(action);
			set.forEach(bindings::remove);
			actions.remove(action);
		}

		/**
		 * Removes <b>all</b> bindings.
		 */
		public void clear() {
			actions.clear();
			bindings.clear();
		}

//		@Override
//		public void handle(Object handle) {
//		}
//
//		@Override
//		public void handle(InputEvent event) {
//			binding(event.type()).ifPresent(action -> action.execute(event));
//		}



		public EventHandler handler() {
			return new EventHandler() {
				@Override
				public void handle(Position event) {
					final var action = binding(event.type());
					action.get().execute(event);
				}

				@Override
				public void handle(Button.Event event) {
				}

				@Override
				public void handle(Axis.Event event) {
				}
			};
		}



		/**
		 * Writes this set of bindings to the given output stream.
		 * <p>
		 * The bindings for each action are written as separate lines as follows: <code>action event event...</code>
		 * <br>
		 * where <i>action</i> is the {@link Action#toString()} representation of the action and each <i>event</i> is generated by the {@link InputEvent.Type#describe()} method.
		 * <p>
		 * @param out Output stream
		 */
		public void write(OutputStream out) {
			try(final var writer = new PrintWriter(out)) {
				for(Action action : actions.keySet()) {
					final StringJoiner str = new StringJoiner(DELIMITER);
					str.add(action.toString());
					actions.get(action).stream().map(Object::toString).forEach(str::add);
					writer.println(str);
				}
			}
		}

		/**
		 * Loads a set of bindings from the given input stream.
		 * @param in Input stream
		 * @throws IOException if the bindings cannot be loaded
		 * @throws IllegalArgumentException if a binding cannot be parsed
		 * @see #write(OutputStream)
		 */
		public void load(InputStream in) throws IOException {
			try(final var reader = new BufferedReader(new InputStreamReader(in))) {
				reader
						.lines()
						.map(str -> str.split(DELIMITER))
						.forEach(this::load);
			}
		}

		/**
		 * Loads bindings for an action.
		 * @throws IllegalArgumentException if a binding cannot be parsed
		 */
		private void load(String[] tokens) {
			// Lookup action
			final Action action = actions
					.keySet()
					.stream()
					.filter(e -> e.toString().equals(tokens[0]))
					.findAny()
					.orElseThrow(() -> new IllegalArgumentException("Action not present: " + tokens[0]));

			// Bind events to this action
			Arrays.stream(tokens)
					.skip(1)
					.map(AbstractInputEventType::parse)
					.forEach(e -> bind(e, action));
		}

		@Override
		public String toString() {
			return new ToStringBuilder(this)
					.append("actions", actions.size())
					.append("bindings", bindings.size())
					.build();
		}
	}
}
