package org.sarge.jove.control;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.Reader;
import java.io.Writer;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.StringJoiner;
import java.util.function.Consumer;
import java.util.stream.Stream;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.builder.ToStringBuilder;
import org.sarge.jove.control.InputEvent.Type;
import org.sarge.jove.util.Check;

/**
 * An <i>action</i> performs some operation in response to an {@link InputEvent}.
 * @author Sarge
 */
@FunctionalInterface
public interface Action<T extends Type> extends Consumer<InputEvent<T>> {
	/**
	 * An <i>action bindings</i> maps input events to actions.
	 */
	class Bindings<T extends Type> implements Consumer<InputEvent<T>> {
		private static final String DELIMITER = StringUtils.SPACE;
		private static final InputEvent.Type.Parser PARSER = new InputEvent.Type.Parser();

		private final Map<Action<T>, Set<InputEvent.Type>> actions = new HashMap<>();
		private final Map<InputEvent.Type, Action<T>> bindings = new HashMap<>();

		/**
		 * Adds an action to this set of bindings.
		 * @param action Action
		 * @throws IllegalArgumentException for a duplicate action
		 */
		public void add(Action<T> action) {
			Check.notNull(action);
			if(actions.containsKey(action)) throw new IllegalArgumentException("Duplicate action: " + action);
			actions.put(action, new HashSet<>());
		}

		/**
		 * @return Actions in this set of bindings
		 */
		public Stream<Action<T>> actions() {
			return actions.keySet().stream();
		}

		/**
		 * Helper - Looks up the bindings for the given action.
		 * @param action Action
		 * @return Bindings
		 */
		private Set<InputEvent.Type> get(Action<?> action) {
			final var bindings = actions.get(action);
			if(bindings == null) throw new IllegalArgumentException("Action not present: " + action);
			return bindings;
		}

		/**
		 * Looks up all events bound to the given action.
		 * @param action Action
		 * @return Input events bound to the given action
		 * @throws IllegalArgumentException if the action is not present in this set of bindings
		 */
		public Stream<InputEvent.Type> bindings(Action<?> action) {
			return get(action).stream();
		}

		/**
		 * Looks up the action bound to an event.
		 * @param type Input type
		 * @return Action
		 */
		public Optional<Action<T>> binding(InputEvent.Type type) {
			return Optional.ofNullable(bindings.get(type));
		}

		/**
		 * Binds an input event to the given action.
		 * @param type			Input event
		 * @param action		Action
		 * @throws IllegalStateException if the event is already bound
		 */
		public void bind(InputEvent.Type type, Action<T> action) {
			Check.notNull(type);
			if(bindings.containsKey(type)) throw new IllegalStateException("Event is already bound: " + type);
			actions.computeIfAbsent(action, ignored -> new HashSet<>()).add(type);
			bindings.put(type, action);
		}

		/**
		 * Binds an input event to the given anonymous action handler.
		 * @param type			Input event
		 * @param action		Action
		 * @throws IllegalStateException if the event is already bound
		 */
		public void bind(InputEvent.Type type, Runnable handler) {
			bind(type, ignored -> handler.run());
		}

		/**
		 * Removes the binding for the given type of event.
		 * @param type Event type
		 */
		public void remove(InputEvent.Type type) {
			final Action<T> action = bindings.remove(type);
			if(action != null) {
				actions.get(action).remove(type);
			}
		}

		/**
		 * Removes <b>all</b> bindings for the given action.
		 * @param action Action
		 * @throws IllegalArgumentException if the action is not present
		 */
		public void remove(Action<?> action) {
			final var set = get(action);
			set.forEach(bindings::remove);
			set.clear();
		}

		/**
		 * Removes <b>all</b> bindings.
		 */
		public void clear() {
			actions.values().forEach(Set::clear);
			bindings.clear();
		}

		@Override
		public void accept(InputEvent<T> event) {
			final Action<T> action = bindings.get(event.type());
			if(action != null) {
				action.accept(event);
			}
		}

		// TODO
		// - loader class
		// - pre-build map of names -> actions
		// - parser (static?)

		/**
		 * Writes this set of bindings to the given output stream.
		 * <p>
		 * The bindings for each action are written as separate lines as follows:
		 * <br>
		 * <code>action event event...</code>
		 * <p>
		 * where:
		 * <ul>
		 * <li><i>action</i> is the {@link Action#toString()} representation of the action</li>
		 * <li>each <i>event</i> is generated by {@link InputEvent.Type#write(InputEvent.Type)}</li>
		 * </ul>
		 * <p>
		 * @param out Output stream
		 */
		public void write(Writer out) {
			try(final var writer = new PrintWriter(out)) {
				for(Action<?> action : actions.keySet()) {
					final StringJoiner str = new StringJoiner(StringUtils.SPACE);
					str.add(action.toString());
					actions.get(action).stream().map(Bindings::write).forEach(str::add);
					writer.println(str);
				}
			}
		}

		/**
		 * @return String representation of the given event type
		 */
		private static String write(Type type) {
			final StringBuilder sb = new StringBuilder();
			sb.append(type.getClass().getName());
			sb.append(DELIMITER);
			sb.append(type.name());
			return sb.toString();
		}

		/**
		 * Loads a set of bindings from the given input stream.
		 * @param in Input stream
		 * @throws IOException if the bindings cannot be loaded
		 * @throws IllegalArgumentException if a binding cannot be parsed
		 * @see #write(OutputStream)
		 */
		public void load(Reader r) throws IOException {
			try(final var in = new BufferedReader(r)) {
				in.lines().forEach(this::load);
			}
		}

		/**
		 * Loads bindings for an action.
		 * @throws IllegalArgumentException if a binding cannot be parsed
		 */
		private void load(String line) {
			// Tokenize
			final String[] tokens = StringUtils.split(line);

			// Lookup action
			final Action<T> action = actions
					.keySet()
					.stream()
					.filter(e -> e.toString().equals(tokens[0]))
					.findAny()
					.orElseThrow(() -> new IllegalArgumentException("Action not present: " + tokens[0]));

			// Bind events to this action
			Arrays.stream(tokens)
					.skip(1)
					.map(PARSER::parse)
					.forEach(e -> bind(e, action));
		}

		@Override
		public String toString() {
			return new ToStringBuilder(this)
					.append("actions", actions.size())
					.append("bindings", bindings.size())
					.build();
		}
	}
}
