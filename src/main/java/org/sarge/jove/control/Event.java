package org.sarge.jove.control;

import static org.sarge.lib.util.Check.notNull;
import static org.sarge.lib.util.Check.zeroOrMore;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.builder.HashCodeBuilder;
import org.sarge.lib.util.AbstractEqualsObject;

/**
 * An <i>event</i> describes a platform-independent input action generated by a controller.
 * <p>
 * Examples:
 * <pre>
 * // Create a move event
 * final Event move = new Event(Descriptor.MOVE, x, y);
 *
 * // Create a button event
 * final Event button = new Event(new Descriptor(Category.BUTTON, key, Operation.PRESS));
 * </pre>
 * Notes:
 * <ul>
 * <li>the {@link Operation#REPEAT} operation is only valid for a {@link Category#BUTTON} event</li>
 * <li>{@link Descriptor#parse(String)} can be used to load an event descriptor</li>
 * </ul>
 * @author Sarge
 */
public final class Event extends AbstractEqualsObject {
	/**
	 * Event handler.
	 */
	@FunctionalInterface
	public interface Handler {
		/**
		 * Handles an event.
		 * @param event Event
		 */
		void handle(Event event);
	}

	/**
	 * An <i>operation</i> specifies whether a button is being pressed or released.
	 */
	public enum Operation {
		PRESS,
		RELEASE,
		REPEAT
	}

	/**
	 * Keyboard modifiers.
	 */
	public enum Modifier {
		CTRL,
		SHIFT,
		ALT,
		SUPER,
	}

	/**
	 * Event category.
	 */
	public enum Category {
		/**
		 * Keyboard or controller button press.
		 */
		BUTTON,

		/**
		 * Mouse or screen click.
		 */
		CLICK,

		/**
		 * Mouse movement.
		 */
		MOVE,

		/**
		 * Mouse or screen zoom.
		 */
		ZOOM;

		// TODO - enter/leave window event?
		// TODO - combine move/drag and add boolean?

		/**
		 * @return Whether this event category requires window location arguments
		 */
		private boolean isLocationEvent() {
			switch(this) {
			case MOVE:
			case CLICK:
			case ZOOM:
				return true;

			default:
				return false;
			}
		}
	}

	/**
	 * An <i>event descriptor</i> is the static description of an event.
	 */
	public static final class Descriptor extends AbstractEqualsObject {
		/**
		 * String delimiter.
		 */
		private static final char DELIMITER = '-';

		/**
		 * Descriptor for a move event.
		 */
		public static final Descriptor MOVE = new Descriptor(Event.Category.MOVE);

		/**
		 * Descriptor for a zoom event.
		 */
		public static final Descriptor ZOOM = new Descriptor(Event.Category.ZOOM);

		/**
		 * Parses an event descriptor.
		 * <p>
		 * The string format is: <tt>category</tt> or <tt>category-operation-id</tt> (all upper-case).
		 * <p>
		 * Examples:
		 * <pre>
		 * ZOOM
		 * MOVE
		 * BUTTON-PRESS-1
		 * CLICK-RELEASE-2
		 * </pre>
		 * @param str String representation of an event descriptor
		 * @return Descriptor
		 * @throws IllegalArgumentException if the given string is not a valid event descriptor
		 */
		public static Descriptor parse(String str) {
			// Tokenize
			final String[] tokens = StringUtils.split(str, DELIMITER);
			if(tokens.length == 0) throw new IllegalArgumentException("Descriptor cannot be empty");

			// Convert to descriptor
			final Category cat = Category.valueOf(tokens[0]);
			if(tokens.length == 1) {
				// Simple descriptor
				if(tokens[0].equals(MOVE.toString())) {
					return MOVE;
				}
				else
				if(tokens[0].equals(ZOOM.toString())) {
					return ZOOM;
				}
				else {
					throw new IllegalArgumentException("Invalid event descriptor: " + str);
				}
			}
			else {
				// Button or click descriptor
				if(tokens.length != 3) throw new IllegalArgumentException("Invalid button event descriptor: " + str);
				final Operation op = Operation.valueOf(tokens[1]);
				final int id = Integer.parseInt(tokens[2]);
				return new Descriptor(cat, id, op);
			}
		}

		private final Category cat;
		private final int id;
		private final Operation op;
		private final transient int hash;

		/**
		 * Constructor.
		 * @param cat Event category
		 */
		private Descriptor(Category cat) {
			this.cat = notNull(cat);
			this.id = 0;
			this.op = null;
			this.hash = cat.hashCode();
			assert (cat == Category.MOVE) || (cat == Category.ZOOM);
		}

		/**
		 * Constructor.
		 * @param cat Event category
		 */
		public Descriptor(Category cat, int id, Operation op) {
			this.cat = notNull(cat);
			this.id = zeroOrMore(id);
			this.op = notNull(op);
			this.hash = new HashCodeBuilder().append(cat).append(id).append(op).hashCode();
			verify();
		}

		private void verify() {
			switch(cat) {
			case MOVE:
			case ZOOM:
				throw new IllegalArgumentException("Expected BUTTON or CLICK category");

			case CLICK:
				if(op == Operation.REPEAT) throw new IllegalArgumentException("Invalid operation for category: " + this);
				break;
			}
		}

		/**
		 * @return Event category
		 */
		public Category category() {
			return cat;
		}

		/**
		 * @return Button identifier
		 */
		public int id() {
			return id;
		}

		/**
		 * @return Button operation
		 */
		public Operation operation() {
			return op;
		}

		@Override
		public int hashCode() {
			return hash;
		}

		@Override
		public String toString() {
			if(op == null) {
				return cat.name();
			}
			else {
				final StringBuilder sb = new StringBuilder();
				sb.append(cat);
				sb.append(DELIMITER);
				sb.append(op);
				sb.append(DELIMITER);
				sb.append(id);
				return sb.toString();
			}
		}
	}

	private final Descriptor descriptor;

	public final int x, y;

	/**
	 * Constructor.
	 * @param descriptor Event descriptor
	 * @param x
	 * @param y
	 */
	public Event(Descriptor descriptor, int x, int y) {
		if(!descriptor.cat.isLocationEvent()) throw new IllegalArgumentException("Invalid location event descriptor: " + descriptor);
		this.descriptor = notNull(descriptor);
		this.x = x;
		this.y = y;
	}

	/**
	 * Constructor.
	 * @param descriptor Event descriptor
	 */
	public Event(Descriptor descriptor) {
		if(descriptor.cat.isLocationEvent()) throw new IllegalArgumentException("Invalid event descriptor: " + descriptor);
		this.descriptor = notNull(descriptor);
		this.x = 0;
		this.y = 0;
	}

	/**
	 * @return Event descriptor
	 */
	public Descriptor descriptor() {
		return descriptor;
	}
}
