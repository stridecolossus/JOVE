package org.sarge.jove.control;

import static org.sarge.lib.util.Check.notNull;
import static org.sarge.lib.util.Check.zeroOrMore;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.builder.EqualsBuilder;
import org.apache.commons.lang3.builder.HashCodeBuilder;
import org.sarge.lib.util.AbstractEqualsObject;

/**
 * An <i>event</i> describes a input action generated by a controller.
 * @author Sarge
 */
public final class Event extends AbstractEqualsObject {
	// TODO
	// https://stackoverflow.com/questions/15313469/java-keyboard-keycodes-list

	/**
	 * Event handler.
	 */
	@FunctionalInterface
	public interface Handler {
		/**
		 * Handles an event.
		 * @param event Event
		 */
		void handle(Event event);
	}

	/**
	 * Event sub-type.
	 * TODO - this is a crap name, only for keyboard/mouse buttons
	 */
	public enum Type {
		/**
		 * Button or key press.
		 */
		PRESS,

		/**
		 * Button or key release.
		 */
		RELEASE,

		/**
		 * Double-click.
		 */
		DOUBLE
		// TODO - used?
		// TODO - repeating?
	}

	/**
	 * Keyboard modifiers.
	 */
	public enum Modifier {
		CTRL,
		SHIFT,
		ALT,
		SUPER,
	}

	/**
	 * Event category.
	 */
	public enum Category {
		/**
		 * Keyboard or controller button press.
		 */
		BUTTON,

		/**
		 * Mouse or screen click.
		 */
		CLICK,

		/**
		 * Mouse movement.
		 */
		MOVE,

		/**
		 * Mouse or screen zoom.
		 */
		ZOOM;

		// TODO - enter/leave window event?
		// TODO - combine move/drag and add boolean?

		/**
		 * @return Whether this event category requires an identifier
		 */
		private boolean isIdentified() {
			switch(this) {
			case BUTTON:
			case CLICK:
				return true;

			default:
				return false;
			}
		}

		/**
		 * @return Whether this event category requires window location arguments
		 */
		private boolean isLocationEvent() {
			switch(this) {
			case MOVE:
			case ZOOM:
				return true;

			default:
				return false;
			}
		}

		/**
		 * @return Whether this event category requires a sub-type argument
		 */
		private boolean isTypeEvent() {
			switch(this) {
			case BUTTON:
			case CLICK:
				return true;

			default:
				return false;
			}
		}
	}

	/**
	 * Event key.
	 * TODO - consider splitting into IndexedKey and DefaultKey?
	 * IndexedKey = cat, type, id, mods, event
	 * DefaultKey = cat, type, mods, x, y
	 */
	public static final class Key {
		/**
		 * String delimiter.
		 */
		private static final char DELIMITER = '-';

		/**
		 * Move event key.
		 */
		public static final Key MOVE = new Key(Category.MOVE);

		/**
		 * Zoom event-key.
		 */
		public static final Key ZOOM = new Key(Category.ZOOM);

		/**
		 * Array-based cache for indexed event keys.
		 */
		private static class Cache {
			private static final int TYPE_COUNT = Type.values().length;

			private final Key[] cache;
			private final int size;

			/**
			 * Constructor.
			 * @param cat		Category
			 * @param size		Cache size
			 */
			Cache(Category cat, int size) {
				this.size = size;
				this.cache = new Key[TYPE_COUNT * size];
				populate(cat, size);
			}

			/**
			 * Populates the cache.
			 */
			private void populate(Category cat, int size) {
				int index = 0;
				for(Type type : Type.values()) {
					for(int n = 0; n < size; ++n) {
						cache[index] = new Key(cat, type, n);
						++index;
					}
				}
			}

			/**
			 * Looks up a cached key.
			 */
			public Key get(Type type, int id) {
				final int index = type.ordinal() * size + id;
				return cache[index];
			}
		}

		/**
		 * Cache for button events.
		 */
		private static final Cache BUTTON_CACHE = new Cache(Category.BUTTON, 350);

		/**
		 * Cache for click events.
		 */
		private static final Cache CLICK_CACHE = new Cache(Category.CLICK, 16);

		/**
		 * Looks up an indexed event key.
		 * @param cat		Event category
		 * @param type		Type
		 * @param id		Identifier
		 * @return Event key
		 * @throws IllegalArgumentException if the given category is not indexed
		 */
		public static Key of(Category cat, Type type, int id) {
			switch(cat) {
			case BUTTON:	return BUTTON_CACHE.get(type, id);
			case CLICK:		return CLICK_CACHE.get(type, id);
			default:		throw new IllegalArgumentException("Invalid event category: " + cat);
			}
		}

		/**
		 * Creates an event key from the given string representation.
		 * @param key Key string
		 * @return Event key
		 * @throws IllegalArgumentException if the string is not a valid key representation
		 * @see #toString()
		 */
		public static Key parse(String key) {
			final String[] tokens = StringUtils.split(key, DELIMITER);
			final Category cat = Category.valueOf(tokens[0]);
			final Type type = Type.valueOf(tokens[1]);
			final int id = Integer.parseInt(tokens[2]);
			return new Key(cat, type, id);
		}

		private final Category cat;
		private final Type type;
		private final int id;

		private final transient int hash;
		private final transient Event event;

		/**
		 * Constructor.
		 * @param cat		Event category
		 * @param type		Event type or <tt>null</tt> for events that do not support types
		 * @param id		Event identifier 0..n
		 * @throws IllegalArgumentException if the key is not valid
		 */
		private Key(Category cat, Type type, int id) {
			this.cat = notNull(cat);
			this.type = type;
			this.id = zeroOrMore(id);
			this.hash = new HashCodeBuilder().append(cat).append(type).append(id).hashCode();
			if(cat.isLocationEvent()) {
				this.event = null;
			}
			else {
				this.event = new Event(this);
			}
			assert verify();
		}

		/**
		 * Constructor for a non-indexed key.
		 * @param cat Event category
		 */
		private Key(Category cat) {
			this.cat = notNull(cat);
			this.type = null;
			this.id = -1;
			this.hash = new HashCodeBuilder().append(cat).hashCode();
			this.event = null;
			assert verify();
		}

		/**
		 * @throws IllegalArgumentException if the key is not valid
		 */
		private boolean verify() {
			if(cat.isTypeEvent() == (type == null)) throw new IllegalArgumentException("Invalid type for event");
			if(cat.isIdentified() == (id == -1)) throw new IllegalArgumentException("Invalid ID for event");
			return true;
		}

		/**
		 * @return Event category
		 */
		public Category category() {
			return cat;
		}

		/**
		 * @return Event type
		 */
		public Type type() {
			return type;
		}

		/**
		 * @return Event identifier
		 */
		public int identifier() {
			return id;
		}

		/**
		 * @return Cached instance for a non-location based event
		 */
		public Event event() {
			return event;
		}

		@Override
		public boolean equals(Object that) {
			return EqualsBuilder.reflectionEquals(this, that);
		}

		@Override
		public int hashCode() {
			return hash;
		}

		@Override
		public String toString() {
			final StringBuilder sb = new StringBuilder();
			sb.append(cat);
			if(type != null) {
				sb.append(DELIMITER);
				sb.append(type);
			}
			if(id >= 0) {
				sb.append(DELIMITER);
				sb.append(id);
			}
			return sb.toString();
		}
	}

	private final Key key;
	private final int x, y;

	/**
	 * Constructor.
	 * @param key		Event key
	 * @param x			X coordinate
	 * @param y			Y coordinate
	 * @throws IllegalArgumentException if the given key does not require coordinates
	 * TODO - move to factory method on key
	 * TODO - indexed and non-indexed?
	 */
	public Event(Key key, int x, int y) {
		if(!key.cat.isLocationEvent()) throw new IllegalArgumentException("Event does not accept coordinates: " + key);
		this.key = notNull(key);
		this.x = x;
		this.y = y;
	}

	/**
	 * Constructor.
	 * @param key Event key
	 * @throws IllegalArgumentException if the given key requires coordinates
	 */
	private Event(Key key) {
		if(key.cat.isLocationEvent()) throw new IllegalArgumentException("Event requires coordinates: " + key);
		this.key = notNull(key);
		this.x = 0;
		this.y = 0;
	}

	/**
	 * @return Event key
	 */
	public Key key() {
		return key;
	}

	/**
	 * @return X coordinate
	 */
	public int x() {
		return x;
	}

	/**
	 * @return Y coordinate
	 */
	public int y() {
		return y;
	}
}
