package org.sarge.jove.control;

import static org.sarge.lib.util.Check.notNull;
import static org.sarge.lib.util.Check.zeroOrMore;

import java.util.HashMap;
import java.util.Map;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.builder.HashCodeBuilder;
import org.sarge.jove.control.Event.Descriptor.ButtonDescriptor;
import org.sarge.lib.util.AbstractEqualsObject;

/**
 * An <i>event</i> describes a platform-independent input action generated by a controller.
 * <p>
 * Examples:
 * <pre>
 * // Create a move event
 * final Event move = Event.of(Descriptor.MOVE, x, y);
 *
 * // Create a zoom event
 * final Event zoom = Event.of(Descriptor.ZOOM, x, y);
 *
 * // Create a button event
 * final Event button = Event.of(Descriptor.of(Category.BUTTON, key, Operation.PRESS));
 *
 * // Create a click event
 * final Operation op = ...
 * final Event button = Event.of(Descriptor.of(Category.CLICK, mouseButton, op), x, y);
 * </pre>
 * Notes:
 * <ul>
 * <li>button and click event descriptors are cached internally</li>
 * <li>the {@link Operation#REPEAT} operation is only valid for a {@link Category#BUTTON} event</li>
 * </ul>
 * @author Sarge
 */
public final class Event extends AbstractEqualsObject {
	// TODO
	// https://stackoverflow.com/questions/15313469/java-keyboard-keycodes-list

	/**
	 * Event handler.
	 */
	@FunctionalInterface
	public interface Handler {
		/**
		 * Handles an event.
		 * @param event Event
		 */
		void handle(Event event);
	}

	/**
	 * An <i>operation</i> specifies whether a button is being pressed or released.
	 */
	public enum Operation {
		PRESS,
		RELEASE,
		REPEAT
	}

	/**
	 * Keyboard modifiers.
	 */
	public enum Modifier {
		CTRL,
		SHIFT,
		ALT,
		SUPER,
	}

	/**
	 * Event category.
	 */
	public enum Category {
		/**
		 * Keyboard or controller button press.
		 */
		BUTTON,

		/**
		 * Mouse or screen click.
		 */
		CLICK,

		/**
		 * Mouse movement.
		 */
		MOVE,

		/**
		 * Mouse or screen zoom.
		 */
		ZOOM;

		// TODO - enter/leave window event?
		// TODO - combine move/drag and add boolean?

		/**
		 * @return Whether this event category requires window location arguments
		 */
		private boolean isLocationEvent() {
			switch(this) {
			case MOVE:
			case CLICK:
			case ZOOM:
				return true;

			default:
				return false;
			}
		}
	}

	/**
	 * An <i>event descriptor</i> is the static description of an event.
	 */
	public static class Descriptor extends AbstractEqualsObject {
		/**
		 * String delimiter.
		 */
		private static final char DELIMITER = '-';

		/**
		 * Descriptor for a move event.
		 */
		public static final Descriptor MOVE = new Descriptor(Event.Category.MOVE);

		/**
		 * Descriptor for a zoom event.
		 */
		public static final Descriptor ZOOM = new Descriptor(Event.Category.ZOOM);

		/**
		 * Descriptor for a cached button or click event.
		 */
		protected static class ButtonDescriptor extends Descriptor {
			private final int id;
			private final Operation op;

			private final transient int hash;
			private final transient Event event;

			/**
			 * Constructor.
			 * @param cat		Event category
			 * @param id		Button identifier
			 * @param op		Button operation
			 */
			private ButtonDescriptor(Category cat, int id, Operation op) {
				super(cat);
				assert (cat == Category.BUTTON) || (cat == Category.CLICK);
				this.id = zeroOrMore(id);
				this.op = notNull(op);
				this.hash = new HashCodeBuilder().append(cat).append(id).append(op).hashCode();
				this.event = new Event(this, 0, 0);
			}

			@Override
			public int id() {
				return id;
			}

			@Override
			public Operation operation() {
				return op;
			}

			@Override
			public int hashCode() {
				return hash;
			}

			@Override
			public String toString() {
				final StringBuilder sb = new StringBuilder();
				sb.append(cat);
				sb.append(DELIMITER);
				sb.append(op);
				sb.append(DELIMITER);
				sb.append(id);
				return sb.toString();
			}
		}

		/**
		 * Descriptor cache.
		 */
		private static class Cache {
			private final Category cat;
			private final Map<String, ButtonDescriptor> cache = new HashMap<>();

			/**
			 * Constructor.
			 * @param cat Category
			 */
			private Cache(Category cat) {
				this.cat = cat;
			}

			/**
			 * Looks up a cached button descriptor.
			 * @param id Button id
			 * @param op Button operation
			 * @return Button descriptor
			 */
			private ButtonDescriptor get(int id, Operation op) {
				final String key = op.name() + String.valueOf(id);
				return cache.computeIfAbsent(key, ignored -> new ButtonDescriptor(cat, id, op));
			}
		}

		private static final Cache BUTTON = new Cache(Category.BUTTON);
		private static final Cache CLICK = new Cache(Category.CLICK);

		/**
		 * Creates an event descriptor for the given category.
		 * @param cat Event category
		 * @return Descriptor
		 * @return if the given category is not {@link Category#MOVE} or {@link Category#ZOOM}
		 */
		public static Descriptor of(Category cat) {
			switch(cat) {
			case MOVE:		return Descriptor.MOVE;
			case ZOOM:		return Descriptor.ZOOM;
			default:		throw new IllegalArgumentException("Expected ZOOM or MOVE category");
			}
		}

		/**
		 * Creates an event descriptor for the given category.
		 * @param cat		Category
		 * @param id		Button identifier
		 * @param op		Button operation
		 * @return if the given category is not {@link Category#BUTTON} or {@link Category#CLICK}
		 */
		public static Descriptor of(Category cat, int id, Operation op) {
			switch(cat) {
			case BUTTON:
				return BUTTON.get(id, op);

			case CLICK:
				if(op == Operation.REPEAT) throw new IllegalArgumentException(String.format("Invalid operation for category: cat=%s op=%s", cat, op));
				return CLICK.get(id, op);

			default:
				throw new IllegalArgumentException("Expected BUTTON or CLICK category");
			}
		}

		/**
		 * Parses an event descriptor.
		 * <p>
		 * The string format is: <tt>category</tt> or <tt>category-operation-id</tt> (all upper-case).
		 * <p>
		 * Examples:
		 * <pre>
		 * ZOOM
		 * MOVE
		 * BUTTON-PRESS-1
		 * CLICK-RELEASE-2
		 * </pre>
		 * @param str String representation of an event descriptor
		 * @return Descriptor
		 * @throws IllegalArgumentException if the given string is not a valid event descriptor
		 */
		public static Descriptor parse(String str) {
			// Tokenize
			final String[] tokens = StringUtils.split(str, DELIMITER);
			if(tokens.length == 0) throw new IllegalArgumentException("Descriptor cannot be empty");

			// Convert to descriptor
			final Category cat = Category.valueOf(tokens[0]);
			if(tokens.length == 1) {
				// Simple descriptor
				return Descriptor.of(cat);
			}
			else {
				// Named descriptor
				if(tokens.length != 3) throw new IllegalArgumentException("Invalid button event descriptor: " + str);
				final Operation op = Operation.valueOf(tokens[1]);
				final int id = Integer.parseInt(tokens[2]);
				return Descriptor.of(cat, id, op);
			}
		}

		protected final Category cat;

		/**
		 * Constructor.
		 * @param cat Event category
		 */
		private Descriptor(Category cat) {
			this.cat = notNull(cat);
		}

		/**
		 * @return Event category
		 */
		public Category category() {
			return cat;
		}

		/**
		 * @return Button identifier
		 */
		public int id() {
			return 0;
		}

		/**
		 * @return Button operation
		 */
		public Operation operation() {
			return null;
		}

		@Override
		public int hashCode() {
			return cat.hashCode();
		}

		@Override
		public String toString() {
			return cat.name();
		}
	}

	/**
	 * Creates a button event.
	 * @param descriptor Button descriptor
	 * @return Button event
	 * @throws IllegalArgumentException if the given descriptor is not {@link Category#BUTTON}
	 */
	public static Event of(Descriptor descriptor) {
		if(descriptor.cat != Category.BUTTON) throw new IllegalArgumentException("Expected button event descriptor: " + descriptor);
		final ButtonDescriptor button = (ButtonDescriptor) descriptor;
		return button.event;
	}

	/**
	 * Creates a location event.
	 * @param descriptor	Descriptor
	 * @param x				X coordinate
	 * @param y				Y coordinate
	 * @return Location event
	 * @throws IllegalArgumentException if the given descriptor does not have a location
	 * @see Category#isLocationEvent()
	 */
	public static Event of(Descriptor descriptor, int x, int y) {
		if(!descriptor.cat.isLocationEvent()) throw new IllegalArgumentException("Invalid location event descriptor: " + descriptor);
		return new Event(descriptor, x, y);
	}

	private final Descriptor descriptor;

	public final int x, y;

	/**
	 * Constructor.
	 * @param descriptor		Event descriptor
	 * @param x
	 * @param y
	 */
	private Event(Descriptor descriptor, int x, int y) {
		this.descriptor = notNull(descriptor);
		this.x = x;
		this.y = y;
	}

	/**
	 * @return Event descriptor
	 */
	public Descriptor descriptor() {
		return descriptor;
	}
}
