package org.sarge.jove.control;

import static org.sarge.jove.util.Check.notNull;
import static org.sarge.jove.util.Check.zeroOrMore;

import java.util.Objects;
import java.util.StringJoiner;

import org.apache.commons.lang3.builder.ToStringBuilder;
import org.sarge.jove.util.Check;
import org.sarge.jove.util.MathsUtil;

/**
 * An <i>input event</i> describes an event generated by a {@link Device}.
 * @author Sarge
 */
public final class InputEvent {
	private static final String DELIMITER = "-";

	/**
	 * An <i>input event type</i> defines the type of an event, e.g. the name of a keyboard button.
	 */
	public interface Type {
//		/**
//		 * Generates the textual representation of this descriptor.
//		 * @return Description
//		 */
//		String describe();

		/**
		 * Position descriptor singleton instance.
		 */
		Position POSITION = new Position();

		/**
		 * A <i>position descriptor</i> describes a mouse, controller, or joystick movement.
		 */
		final class Position implements Type {
			private static final String NAME = "Position";

			private Position() {
			}

			/**
			 * Creates a position event.
			 * @param x X coordinate
			 * @param y Y coordinate
			 * @return New position event
			 */
			public InputEvent create(float x, float y) {
				return new InputEvent(this, x, y);
			}

			@Override
			public boolean equals(Object obj) {
				return obj == POSITION;
			}

			@Override
			public String toString() {
				return NAME;
			}
		}

		/**
		 * A <i>button</i> describes a keyboard or controller button.
		 * TODO - separate action/mods for keyboard?
		 */
		public static class Button implements Type {
			private static final String NAME = "Button";

			private final int key;
			private final String name;
			private final int action;
			private final int mods;
			private final InputEvent event = new InputEvent(this, 0, 0);
			private final transient int hash;

			/**
			 * Constructor.
			 * @param key		Key code
			 * @param name		Key name
			 * @param action	TODO
			 * @param mods		TODO
			 */
			public Button(int key, String name, int action, int mods) {
				this.key = zeroOrMore(key);
				this.name = name; // TODO - notEmpty(name);
				this.action = action; // TODO
				this.mods = mods; // TODO
				this.hash = Objects.hash(key, action, mods);
			}

			/**
			 * @return Input event for this button
			 */
			public InputEvent event() {
				return event;
			}

			/**
			 * Helper - Parses a button descriptor.
			 */
			private static Button parse(String[] tokens) {
				final int key = Integer.parseInt(tokens[1]);
				final int action = 0;		// TODO
				final int mods = 0;			// TODO
				return new Button(key, tokens[2], action, mods);
			}

			@Override
			public int hashCode() {
				return hash;
			}

			@Override
			public boolean equals(Object obj) {
				if(obj == this) {
					return true;
				}
				else {
					return
							(obj instanceof Button that) &&
							(this.key == that.key) &&
							(this.action == that.action) &&
							(this.mods == that.mods);
				}
			}

			@Override
			public String toString() {
				return new StringJoiner(DELIMITER)
						.add(NAME)
						.add(String.valueOf(key))
						.add(name)
						// TODO - action/mods
						.toString();
			}
		}

		/**
		 * An <i>axis event type</i> describes a controller axis, joystick axis or a mouse-wheel.
		 */
		record Axis(int axis, String name) implements Type {
			private static final String NAME = "Axis";

			public Axis {
				Check.zeroOrMore(axis);
				Check.notEmpty(name);
			}

			/**
			 * Creates an axis event.
			 * The Y coordinate is the axis value.
			 * @param value Axis value
			 * @return New axis event
			 */
			public InputEvent create(float value) {
				return new InputEvent(this, 0, value);
			}

			@Override
			public String toString() {
				return new StringJoiner(DELIMITER)
						.add(NAME)
						.add(String.valueOf(axis))
						.add(name)
						.toString();
			}
		}

		/**
		 * Parses the given string representation of an event type.
		 * @param str String
		 * @return Parsed event type
		 */
		static Type parse(String str) {
			final String[] tokens = str.split(DELIMITER);
			return switch(tokens[0]) {
				case Position.NAME -> POSITION;
				case Button.NAME -> Button.parse(tokens);
				case Axis.NAME -> new Axis(Integer.parseInt(tokens[1]), tokens[2]);
				default -> throw new IllegalArgumentException("Invalid event type: " + str);
			};
		}
	}

	/**
	 * Handler for an input event.
	 */
	public interface Handler {
		/**
		 * Handles the given event.
		 * @param event Event
		 */
		void handle(InputEvent event);
	}

	private final Type type;
	private final float x, y;

	/**
	 * Constructor.
	 * @param type		Event type descriptor
	 * @param x			X coordinate
	 * @param y			Y coordinate
	 */
	private InputEvent(Type type, float x, float y) {
		this.type = notNull(type);
		this.x = x;
		this.y = y;
	}

	/**
	 * @return Event type descriptor
	 */
	public Type type() {
		return type;
	}

	/**
	 * @return X coordinate
	 */
	public float x() {
		return x;
	}

	/**
	 * @return Y coordinate
	 */
	public float y() {
		return y;
	}

	@Override
	public boolean equals(Object obj) {
		return
				(obj instanceof InputEvent that) &&
				this.type.equals(that.type) &&
				MathsUtil.isEqual(this.x, that.x) &&
				MathsUtil.isEqual(this.y, that.y);
	}

	@Override
	public String toString() {
		return ToStringBuilder.reflectionToString(this);
	}
}
