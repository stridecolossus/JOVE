package org.sarge.jove.control;

import java.lang.reflect.Constructor;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Consumer;

import org.sarge.jove.control.InputEvent.Type;

/**
 * An <i>input event</i> describes an event generated by a device.
 * @author Sarge
 */
public interface InputEvent<T extends Type> {
	/**
	 * @return Type of this event
	 */
	Type type();

	/**
	 * An <i>event type</i> is the descriptor for an input event.
	 */
	interface Type {
		/**
		 * Name delimiter.
		 */
		String DELIMITER = "-";

		/**
		 * @return Event name qualifier
		 */
		String name();

		/**
		 * Generates the string representation of the given event-type.
		 * @param type Event-type
		 * @return String representation
		 * @see Parser
		 */
		static String write(Type type) {
			final StringBuilder sb = new StringBuilder();
			sb.append(type.getClass().getName());
			sb.append(DELIMITER);
			sb.append(type.name());
			return sb.toString();
		}

		/**
		 * The <i>event type parser</i> instantiates an event-type from its string representation.
		 * TODO
		 */
		class Parser {
			private final Map<String, Constructor<? extends Type>> registry = new HashMap<>();

			/**
			 * Parses an event-type from its string representation.
			 * @param str String representation of the event
			 * @return Parsed event-type
			 * @throws RuntimeException if the event-type cannot be parsed
			 */
			public Type parse(String str) {
				// Find classname delimiter
				final int idx = str.indexOf(DELIMITER);
				if((idx < 1) || (idx == str.length())) throw new IllegalArgumentException(String.format("Invalid event-type representation: [%s]", str));

				// Lookup constructor
				final Constructor<? extends Type> ctor = registry.computeIfAbsent(str.substring(0, idx), Parser::register);

				// Create event type
				try {
					return ctor.newInstance(str.substring(idx + 1));
				}
				catch(Exception e) {
					throw new RuntimeException(String.format("Error instantiating event-type: [%s]", str), e);
				}
			}

			/**
			 * Looks up the constructor for the given event-type.
			 * @param name Event-type class name
			 * @return constructor
			 * @throws IllegalArgumentException if the event type is unknown or the constructor cannot be found
			 */
			@SuppressWarnings("unchecked")
			private static Constructor<? extends Type> register(String name) {
				try {
					// Lookup class
					final Class<?> clazz = Class.forName(name);
					if(!Type.class.isAssignableFrom(clazz)) throw new IllegalArgumentException("Not an event class: " + name);

					// Lookup constructor
					final Constructor<?> ctor = clazz.getDeclaredConstructor(String.class);
					ctor.setAccessible(true);

					return (Constructor<? extends Type>) ctor;
				}
				catch(ClassNotFoundException e) {
					throw new IllegalArgumentException("Unknown event type: " + name, e);
				}
				catch(NoSuchMethodException e) {
					throw new IllegalArgumentException("Cannot find event constructor: " + name, e);
				}
				catch(IllegalArgumentException e) {
					throw e;
				}
				catch(Exception e) {
					throw new RuntimeException("Error looking up constructor: " + name, e);
				}
			}
		}
	}

	/**
	 * An <i>input event source</i> defines a generator of input events.
	 * @param <T> Type of event
	 */
	interface Source<T extends Type> {
		/**
		 * @return Type of events generated by this source
		 */
		Class<T> type();

		/**
		 * @return Events generated by this source
		 */
		List<T> events();

		/**
		 * Enables generation of events.
		 * @param handler Event handler
		 */
		void enable(Consumer<InputEvent<?>> handler);

		/**
		 * Disables event generation.
		 */
		void disable();
	}

	/**
	 * A <i>device</i> is comprised of a group of event sources.
	 */
	interface Device {
		/**
		 * @return Device name
		 */
		String name();

		/**
		 * @return Event sources for this device
		 */
		Set<Source<?>> sources();

		/**
		 * Enables <b>all</b> event sources for the given device.
		 * @param dev			Device
		 * @param handler		Event handler
		 */
		static void enable(Device dev, Consumer<InputEvent<?>> handler) {
			for(Source<?> src : dev.sources()) {
				src.enable(handler);
			}
		}
	}
}
