package org.sarge.jove.platform.vulkan.render;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.*;

import java.util.*;
import java.util.function.Supplier;

import org.junit.jupiter.api.*;
import org.sarge.jove.common.Handle;
import org.sarge.jove.platform.vulkan.*;
import org.sarge.jove.platform.vulkan.common.*;
import org.sarge.jove.platform.vulkan.core.*;

class FrameComposerTest {
	private DeviceContext dev;
	private FrameComposer composer;
	private Supplier<Command.Buffer> factory;
//	private Supplier<Command.Buffer> seq;
	private Supplier<List<Command>> seq;

	@SuppressWarnings("unchecked")
	@BeforeEach
	void before() {
		dev = new MockDeviceContext();
		factory = mock(Supplier.class);
		seq = mock(Supplier.class);
		composer = new FrameComposer(factory, seq);
	}

	@Test
	void compose() {
		// Create a command pool
		final WorkQueue queue = new WorkQueue(new Handle(1), new WorkQueue.Family(1, 2, Set.of(VkQueueFlag.GRAPHICS)));
		final var pool = Command.Pool.create(dev, queue);

		// Create a render task to be generated by the factory
		final var render = pool.allocate();
		when(factory.get()).thenReturn(render);

		// Create the frame buffer
		final var frame = mock(FrameBuffer.class);
		when(frame.begin()).thenReturn(mock(Command.class));

		// Init the render sequence
		when(seq.get()).thenReturn(List.of());

		// Compose the render task
		assertEquals(render, composer.compose(frame));
		verify(frame).begin();
		verify(seq).get();
	}

	@Test
	void flags() {
		final VkCommandBufferUsage[] flags = {VkCommandBufferUsage.ONE_TIME_SUBMIT};
		composer.flags(flags);
	}
}
